
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>sendgrid: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kenzo0107/sendgrid/alert.go (100.0%)</option>
				
				<option value="file1">github.com/kenzo0107/sendgrid/api_key.go (100.0%)</option>
				
				<option value="file2">github.com/kenzo0107/sendgrid/design.go (100.0%)</option>
				
				<option value="file3">github.com/kenzo0107/sendgrid/enforce_tls.go (100.0%)</option>
				
				<option value="file4">github.com/kenzo0107/sendgrid/event_webhook.go (100.0%)</option>
				
				<option value="file5">github.com/kenzo0107/sendgrid/inbound_parse_webhook.go (100.0%)</option>
				
				<option value="file6">github.com/kenzo0107/sendgrid/ip_addresses.go (100.0%)</option>
				
				<option value="file7">github.com/kenzo0107/sendgrid/link_branding.go (98.8%)</option>
				
				<option value="file8">github.com/kenzo0107/sendgrid/logger.go (100.0%)</option>
				
				<option value="file9">github.com/kenzo0107/sendgrid/mail.go (95.8%)</option>
				
				<option value="file10">github.com/kenzo0107/sendgrid/misc.go (93.5%)</option>
				
				<option value="file11">github.com/kenzo0107/sendgrid/reverse_dns.go (97.9%)</option>
				
				<option value="file12">github.com/kenzo0107/sendgrid/sender_authentication.go (98.2%)</option>
				
				<option value="file13">github.com/kenzo0107/sendgrid/sender_verification.go (98.5%)</option>
				
				<option value="file14">github.com/kenzo0107/sendgrid/sendgrid.go (91.5%)</option>
				
				<option value="file15">github.com/kenzo0107/sendgrid/sso_certificate.go (86.8%)</option>
				
				<option value="file16">github.com/kenzo0107/sendgrid/sso_integration.go (86.0%)</option>
				
				<option value="file17">github.com/kenzo0107/sendgrid/stats.go (90.7%)</option>
				
				<option value="file18">github.com/kenzo0107/sendgrid/subuser.go (87.0%)</option>
				
				<option value="file19">github.com/kenzo0107/sendgrid/suppressions.go (97.3%)</option>
				
				<option value="file20">github.com/kenzo0107/sendgrid/suppressions_unsubscribe_groups.go (86.5%)</option>
				
				<option value="file21">github.com/kenzo0107/sendgrid/teammate.go (98.9%)</option>
				
				<option value="file22">github.com/kenzo0107/sendgrid/template.go (96.4%)</option>
				
				<option value="file23">github.com/kenzo0107/sendgrid/template_version.go (100.0%)</option>
				
				<option value="file24">github.com/kenzo0107/sendgrid/tracking.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package sendgrid

import (
        "context"
        "fmt"
)

type OutputGetAlert struct {
        ID         int64  `json:"id,omitempty"`
        EmailTo    string `json:"email_to,omitempty"`
        Frequency  string `json:"frequency,omitempty"`
        Type       string `json:"type,omitempty"`
        Percentage int64  `json:"percentage,omitempty"`
        CreatedAt  int64  `json:"created_at,omitempty"`
        UpdatedAt  int64  `json:"updated_at,omitempty"`
}

// see: https://www.twilio.com/docs/sendgrid/api-reference/alerts/retrieve-a-specific-alert
func (c *Client) GetAlert(ctx context.Context, id int64) (*OutputGetAlert, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/alerts/%d", id)

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetAlert)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type Alert struct {
        ID         int64  `json:"id,omitempty"`
        EmailTo    string `json:"email_to,omitempty"`
        Frequency  string `json:"frequency,omitempty"`
        Type       string `json:"type,omitempty"`
        Percentage int64  `json:"percentage,omitempty"`
        CreatedAt  int64  `json:"created_at,omitempty"`
        UpdatedAt  int64  `json:"updated_at,omitempty"`
}

// see: https://www.twilio.com/docs/sendgrid/api-reference/alerts/retrieve-all-alerts
func (c *Client) GetAlerts(ctx context.Context) ([]*Alert, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("GET", "/alerts", nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := []*Alert{}
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputCreateAlert struct {
        Type       string `json:"type,omitempty"`
        EmailTo    string `json:"email_to,omitempty"`
        Frequency  string `json:"frequency,omitempty"`
        Percentage int64  `json:"percentage,omitempty"`
}

type OutputCreateAlert struct {
        ID         int64  `json:"id,omitempty"`
        EmailTo    string `json:"email_to,omitempty"`
        Frequency  string `json:"frequency,omitempty"`
        Type       string `json:"type,omitempty"`
        Percentage int64  `json:"percentage,omitempty"`
        CreatedAt  int64  `json:"created_at,omitempty"`
        UpdatedAt  int64  `json:"updated_at,omitempty"`
}

// see: https://www.twilio.com/docs/sendgrid/api-reference/alerts/create-a-new-alert
func (c *Client) CreateAlert(ctx context.Context, input *InputCreateAlert) (*OutputCreateAlert, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("POST", "/alerts", input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputCreateAlert)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateAlert struct {
        EmailTo    string `json:"email_to,omitempty"`
        Frequency  string `json:"frequency,omitempty"`
        Percentage int64  `json:"percentage,omitempty"`
}

type OutputUpdateAlert struct {
        ID         int64  `json:"id,omitempty"`
        EmailTo    string `json:"email_to,omitempty"`
        Frequency  string `json:"frequency,omitempty"`
        Type       string `json:"type,omitempty"`
        Percentage int64  `json:"percentage,omitempty"`
        CreatedAt  int64  `json:"created_at,omitempty"`
        UpdatedAt  int64  `json:"updated_at,omitempty"`
}

// see: https://www.twilio.com/docs/sendgrid/api-reference/alerts/update-an-alert
func (c *Client) UpdateAlert(ctx context.Context, id int64, input *InputUpdateAlert) (*OutputUpdateAlert, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/alerts/%d", id)

        req, err := c.NewRequest("PATCH", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateAlert)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

// see: https://www.twilio.com/docs/sendgrid/api-reference/alerts/delete-an-alert
func (c *Client) DeleteAlert(ctx context.Context, id int64) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/alerts/%d", id)

        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package sendgrid

import (
        "context"
        "fmt"
)

type APIKey struct {
        ApiKeyId string `json:"api_key_id,omitempty"`
        Name     string `json:"name,omitempty"`
}

type OutputGetAPIKeys struct {
        APIKeys []APIKey `json:"result,omitempty"`
}

func (c *Client) GetAPIKeys(ctx context.Context) (*OutputGetAPIKeys, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("GET", "/api_keys", nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetAPIKeys)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type OutputGetAPIKey struct {
        ApiKeyId string   `json:"api_key_id,omitempty"`
        Name     string   `json:"name,omitempty"`
        Scopes   []string `json:"scopes,omitempty"`
}

func (c *Client) GetAPIKey(ctx context.Context, apiKeyId string) (*OutputGetAPIKey, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/api_keys/%s", apiKeyId)
        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetAPIKey)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputCreateAPIKey struct {
        Name   string   `json:"name,omitempty"`
        Scopes []string `json:"scopes,omitempty"`
}

type OutputCreateAPIKey struct {
        ApiKey   string   `json:"api_key,omitempty"`
        ApiKeyId string   `json:"api_key_id,omitempty"`
        Name     string   `json:"name,omitempty"`
        Scopes   []string `json:"scopes,omitempty"`
}

func (c *Client) CreateAPIKey(ctx context.Context, input *InputCreateAPIKey) (*OutputCreateAPIKey, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("POST", "/api_keys", input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputCreateAPIKey)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateAPIKeyName struct {
        Name string `json:"name"`
}

type OutputUpdateAPIKeyName struct {
        ApiKeyId string `json:"api_key_id,omitempty"`
        Name     string `json:"name,omitempty"`
}

func (c *Client) UpdateAPIKeyName(ctx context.Context, apiKeyId string, input *InputUpdateAPIKeyName) (*OutputUpdateAPIKeyName, error) <span class="cov8" title="1">{
        u := fmt.Sprintf("/api_keys/%s", apiKeyId)

        req, err := c.NewRequest("PATCH", u, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateAPIKeyName)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateAPIKeyNameAndScopes struct {
        Name   string   `json:"name"`
        Scopes []string `json:"scopes,omitempty"`
}

type OutputUpdateAPIKeyNameAndScopes struct {
        ApiKeyId string   `json:"api_key_id,omitempty"`
        Name     string   `json:"name"`
        Scopes   []string `json:"scopes,omitempty"`
}

func (c *Client) UpdateAPIKeyNameAndScopes(ctx context.Context, apiKeyId string, input *InputUpdateAPIKeyNameAndScopes) (*OutputUpdateAPIKeyNameAndScopes, error) <span class="cov8" title="1">{
        u := fmt.Sprintf("/api_keys/%s", apiKeyId)

        req, err := c.NewRequest("PUT", u, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateAPIKeyNameAndScopes)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

func (c *Client) DeleteAPIKey(ctx context.Context, apiKeyId string) error <span class="cov8" title="1">{
        u := fmt.Sprintf("/api_keys/%s", apiKeyId)

        req, err := c.NewRequest("DELETE", u, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package sendgrid

import (
        "context"
        "fmt"
)

type Design struct {
        ID           string `json:"id,omitempty"`
        UpdatedAt    string `json:"updated_at,omitempty"`
        CreatedAt    string `json:"created_at,omitempty"`
        ThumbnailURL string `json:"thumbnail_url,omitempty"`
        Name         string `json:"name,omitempty"`
        Editor       string `json:"editor,omitempty"`
}

type _Metadata struct {
        Prev  string `json:"prev,omitempty"`
        Self  string `json:"self,omitempty"`
        Next  string `json:"next,omitempty"`
        Count int64  `json:"count,omitempty"`
}

type OutputGetDesigns struct {
        Result   []*Design `json:"result,omitempty"`
        Metadata _Metadata `json:"_metadata,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/designs-api/list-designs
func (c *Client) GetDesigns(ctx context.Context) (*OutputGetDesigns, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("GET", "/designs", nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetDesigns)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type OutputGetDesign struct {
        ID                   string   `json:"id,omitempty"`
        UpdatedAt            string   `json:"updated_at,omitempty"`
        CreatedAt            string   `json:"created_at,omitempty"`
        ThumbnailURL         string   `json:"thumbnail_url,omitempty"`
        Name                 string   `json:"name,omitempty"`
        Editor               string   `json:"editor,omitempty"`
        HTMLContent          string   `json:"html_content,omitempty"`
        PlainContent         string   `json:"plain_content,omitempty"`
        GeneratePlainContent bool     `json:"generate_plain_content,omitempty"`
        Subject              string   `json:"subject,omitempty"`
        Categories           []string `json:"categories,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/designs-api/get-design
func (c *Client) GetDesign(ctx context.Context, id string) (*OutputGetDesign, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/designs/%s", id)

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetDesign)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputCreateDesign struct {
        Name                 string   `json:"name,omitempty"`
        Editor               string   `json:"editor,omitempty"`
        HTMLContent          string   `json:"html_content,omitempty"`
        PlainContent         string   `json:"plain_content,omitempty"`
        GeneratePlainContent bool     `json:"generate_plain_content"`
        Subject              string   `json:"subject,omitempty"`
        Categories           []string `json:"categories,omitempty"`
}

type OutputCreateDesign struct {
        ID                   string   `json:"id,omitempty"`
        UpdatedAt            string   `json:"updated_at,omitempty"`
        CreatedAt            string   `json:"created_at,omitempty"`
        ThumbnailURL         string   `json:"thumbnail_url,omitempty"`
        Name                 string   `json:"name,omitempty"`
        Editor               string   `json:"editor,omitempty"`
        HTMLContent          string   `json:"html_content,omitempty"`
        PlainContent         string   `json:"plain_content,omitempty"`
        GeneratePlainContent bool     `json:"generate_plain_content,omitempty"`
        Subject              string   `json:"subject,omitempty"`
        Categories           []string `json:"categories,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/designs-api/create-design
func (c *Client) CreateDesign(ctx context.Context, input *InputCreateDesign) (*OutputCreateDesign, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("POST", "/designs", input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputCreateDesign)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateDesign struct {
        Name                 string   `json:"name,omitempty"`
        HTMLContent          string   `json:"html_content,omitempty"`
        PlainContent         string   `json:"plain_content,omitempty"`
        GeneratePlainContent bool     `json:"generate_plain_content"`
        Subject              string   `json:"subject,omitempty"`
        Categories           []string `json:"categories,omitempty"`
}

type OutputUpdateDesign struct {
        ID                   string   `json:"id,omitempty"`
        UpdatedAt            string   `json:"updated_at,omitempty"`
        CreatedAt            string   `json:"created_at,omitempty"`
        ThumbnailURL         string   `json:"thumbnail_url,omitempty"`
        Name                 string   `json:"name,omitempty"`
        Editor               string   `json:"editor,omitempty"`
        HTMLContent          string   `json:"html_content,omitempty"`
        PlainContent         string   `json:"plain_content,omitempty"`
        GeneratePlainContent bool     `json:"generate_plain_content,omitempty"`
        Subject              string   `json:"subject,omitempty"`
        Categories           []string `json:"categories,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/designs-api/update-design
func (c *Client) UpdateDesign(ctx context.Context, id string, input *InputUpdateDesign) (*OutputUpdateDesign, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/designs/%s", id)

        req, err := c.NewRequest("PATCH", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateDesign)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

// see: https://docs.sendgrid.com/api-reference/designs-api/delete-design
func (c *Client) DeleteDesign(ctx context.Context, id string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/designs/%s", id)

        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package sendgrid

import (
        "context"
)

type OutputGetEnforceTLS struct {
        RequireTLS       bool    `json:"require_tls,omitempty"`
        RequireValidCert bool    `json:"require_valid_cert,omitempty"`
        Version          float64 `json:"version,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/settings-enforced-tls/retrieve-current-enforced-tls-settings
func (c *Client) GetEnforceTLS(ctx context.Context) (*OutputGetEnforceTLS, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("GET", "/user/settings/enforced_tls", nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetEnforceTLS)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateEnforceTLS struct {
        RequireTLS       bool    `json:"require_tls"`
        RequireValidCert bool    `json:"require_valid_cert"`
        Version          float64 `json:"version,omitempty"`
}

type OutputUpdateEnforceTLS struct {
        RequireTLS       bool    `json:"require_tls,omitempty"`
        RequireValidCert bool    `json:"require_valid_cert,omitempty"`
        Version          float64 `json:"version,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/settings-enforced-tls/update-enforced-tls-settings
func (c *Client) UpdateEnforceTLS(ctx context.Context, input *InputUpdateEnforceTLS) (*OutputUpdateEnforceTLS, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("PATCH", "/user/settings/enforced_tls", input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateEnforceTLS)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package sendgrid

import (
        "context"
        "fmt"
)

type OutputGetEventWebhook struct {
        ID               string `json:"id,omitempty"`
        Enabled          bool   `json:"enabled,omitempty"`
        URL              string `json:"url,omitempty"`
        GroupResubscribe bool   `json:"group_resubscribe,omitempty"`
        Delivered        bool   `json:"delivered,omitempty"`
        GroupUnsubscribe bool   `json:"group_unsubscribe,omitempty"`
        SpamReport       bool   `json:"spam_report,omitempty"`
        Bounce           bool   `json:"bounce,omitempty"`
        Deferred         bool   `json:"deferred,omitempty"`
        Unsubscribe      bool   `json:"unsubscribe,omitempty"`
        Processed        bool   `json:"processed,omitempty"`
        Open             bool   `json:"open,omitempty"`
        Click            bool   `json:"click,omitempty"`
        Dropped          bool   `json:"dropped,omitempty"`
        FriendlyName     string `json:"friendly_name,omitempty"`
        OAuthClientID    string `json:"oauth_client_id,omitempty"`
        OAuthTokenURL    string `json:"oauth_token_url,omitempty"`
        PublicKey        string `json:"public_key,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/webhooks/get-an-event-webhook
func (c *Client) GetEventWebhook(ctx context.Context, id string) (*OutputGetEventWebhook, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/user/webhooks/event/settings/%s", id)

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetEventWebhook)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type EventWebhook struct {
        ID               string `json:"id,omitempty"`
        Enabled          bool   `json:"enabled,omitempty"`
        URL              string `json:"url,omitempty"`
        GroupResubscribe bool   `json:"group_resubscribe,omitempty"`
        Delivered        bool   `json:"delivered,omitempty"`
        GroupUnsubscribe bool   `json:"group_unsubscribe,omitempty"`
        SpamReport       bool   `json:"spam_report,omitempty"`
        Bounce           bool   `json:"bounce,omitempty"`
        Deferred         bool   `json:"deferred,omitempty"`
        Unsubscribe      bool   `json:"unsubscribe,omitempty"`
        Processed        bool   `json:"processed,omitempty"`
        Open             bool   `json:"open,omitempty"`
        Click            bool   `json:"click,omitempty"`
        Dropped          bool   `json:"dropped,omitempty"`
        FriendlyName     string `json:"friendly_name,omitempty"`
        OAuthClientID    string `json:"oauth_client_id,omitempty"`
        OAuthTokenURL    string `json:"oauth_token_url,omitempty"`
        PublicKey        string `json:"public_key,omitempty"`
}

type OutputGetEventWebhooks struct {
        MaxAllowed int             `json:"max_allowed,omitempty"`
        Webhooks   []*EventWebhook `json:"webhooks,omitempty"`
}

// https://docs.sendgrid.com/api-reference/webhooks/get-all-event-webhooks
func (c *Client) GetEventWebhooks(ctx context.Context) (*OutputGetEventWebhooks, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("GET", "/user/webhooks/event/settings/all", nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetEventWebhooks)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputCreateEventWebhook struct {
        Enabled           bool   `json:"enabled"`
        URL               string `json:"url,omitempty"`
        GroupResubscribe  bool   `json:"group_resubscribe"`
        Delivered         bool   `json:"delivered"`
        GroupUnsubscribe  bool   `json:"group_unsubscribe"`
        SpamReport        bool   `json:"spam_report"`
        Bounce            bool   `json:"bounce"`
        Deferred          bool   `json:"deferred"`
        Unsubscribe       bool   `json:"unsubscribe"`
        Processed         bool   `json:"processed"`
        Open              bool   `json:"open"`
        Click             bool   `json:"click"`
        Dropped           bool   `json:"dropped"`
        FriendlyName      string `json:"friendly_name,omitempty"`
        OAuthClientID     string `json:"oauth_client_id,omitempty"`
        OAuthClientSecret string `json:"oauth_client_secret,omitempty"`
        OAuthTokenURL     string `json:"oauth_token_url,omitempty"`
}

type OutputCreateEventWebhook struct {
        ID                  string `json:"id,omitempty"`
        Enabled             bool   `json:"enabled,omitempty"`
        URL                 string `json:"url,omitempty"`
        AccountStatusChange bool   `json:"account_status_change,omitempty"`
        GroupResubscribe    bool   `json:"group_resubscribe,omitempty"`
        Delivered           bool   `json:"delivered,omitempty"`
        GroupUnsubscribe    bool   `json:"group_unsubscribe,omitempty"`
        SpamReport          bool   `json:"spam_report,omitempty"`
        Bounce              bool   `json:"bounce,omitempty"`
        Deferred            bool   `json:"deferred,omitempty"`
        Unsubscribe         bool   `json:"unsubscribe,omitempty"`
        Processed           bool   `json:"processed,omitempty"`
        Open                bool   `json:"open,omitempty"`
        Click               bool   `json:"click,omitempty"`
        Dropped             bool   `json:"dropped,omitempty"`
        FriendlyName        string `json:"friendly_name,omitempty"`
        CreatedDate         string `json:"created_date,omitempty"`
        UpdatedDate         string `json:"updated_date,omitempty"`
        OAuthClientID       string `json:"oauth_client_id,omitempty"`
        OAuthTokenURL       string `json:"oauth_token_url,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/webhooks/create-an-event-webhook
func (c *Client) CreateEventWebhook(ctx context.Context, input *InputCreateEventWebhook) (*OutputCreateEventWebhook, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("POST", "/user/webhooks/event/settings", input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputCreateEventWebhook)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateEventWebhook struct {
        Enabled           bool   `json:"enabled"`
        URL               string `json:"url,omitempty"`
        GroupResubscribe  bool   `json:"group_resubscribe"`
        Delivered         bool   `json:"delivered"`
        GroupUnsubscribe  bool   `json:"group_unsubscribe"`
        SpamReport        bool   `json:"spam_report"`
        Bounce            bool   `json:"bounce"`
        Deferred          bool   `json:"deferred"`
        Unsubscribe       bool   `json:"unsubscribe"`
        Processed         bool   `json:"processed"`
        Open              bool   `json:"open"`
        Click             bool   `json:"click"`
        Dropped           bool   `json:"dropped"`
        FriendlyName      string `json:"friendly_name,omitempty"`
        OAuthClientID     string `json:"oauth_client_id,omitempty"`
        OAuthClientSecret string `json:"oauth_client_secret,omitempty"`
        OAuthTokenURL     string `json:"oauth_token_url,omitempty"`
}

type OutputUpdateEventWebhook struct {
        ID               string `json:"id,omitempty"`
        Enabled          bool   `json:"enabled,omitempty"`
        URL              string `json:"url,omitempty"`
        GroupResubscribe bool   `json:"group_resubscribe,omitempty"`
        Delivered        bool   `json:"delivered,omitempty"`
        GroupUnsubscribe bool   `json:"group_unsubscribe,omitempty"`
        SpamReport       bool   `json:"spam_report,omitempty"`
        Bounce           bool   `json:"bounce,omitempty"`
        Deferred         bool   `json:"deferred,omitempty"`
        Unsubscribe      bool   `json:"unsubscribe,omitempty"`
        Processed        bool   `json:"processed,omitempty"`
        Open             bool   `json:"open,omitempty"`
        Click            bool   `json:"click,omitempty"`
        Dropped          bool   `json:"dropped,omitempty"`
        FriendlyName     string `json:"friendly_name,omitempty"`
        CreatedDate      string `json:"created_date,omitempty"`
        UpdatedDate      string `json:"updated_date,omitempty"`
        OAuthClientID    string `json:"oauth_client_id,omitempty"`
        OAuthTokenURL    string `json:"oauth_token_url,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/webhooks/update-an-event-webhook
func (c *Client) UpdateEventWebhook(ctx context.Context, id string, input *InputUpdateEventWebhook) (*OutputUpdateEventWebhook, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/user/webhooks/event/settings/%s", id)
        req, err := c.NewRequest("PATCH", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateEventWebhook)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

// see: https://docs.sendgrid.com/api-reference/webhooks/delete-an-event-webhook
func (c *Client) DeleteEventWebhook(ctx context.Context, id string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/user/webhooks/event/settings/%s", id)
        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package sendgrid

import (
        "context"
        "fmt"
)

type OutputGetInboundParseWebhooks struct {
        Result []*InboundParseWebhook `json:"result,omitempty"`
}

type InboundParseWebhook struct {
        URL       string `json:"url,omitempty"`
        Hostname  string `json:"hostname,omitempty"`
        SpamCheck bool   `json:"spam_check,omitempty"`
        SendRaw   bool   `json:"send_raw,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/settings-inbound-parse/retrieve-all-parse-settings
func (c *Client) GetInboundParseWebhooks(ctx context.Context) ([]*InboundParseWebhook, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("GET", "/user/webhooks/parse/settings", nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetInboundParseWebhooks)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r.Result, nil</span>
}

type OutputGetInboundParseWebhook struct {
        URL       string `json:"url,omitempty"`
        Hostname  string `json:"hostname,omitempty"`
        SpamCheck bool   `json:"spam_check,omitempty"`
        SendRaw   bool   `json:"send_raw,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/settings-inbound-parse/retrieve-a-specific-parse-setting
func (c *Client) GetInboundParseWebhook(ctx context.Context, hostname string) (*OutputGetInboundParseWebhook, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/user/webhooks/parse/settings/%s", hostname)

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetInboundParseWebhook)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputCreateInboundParseWebhook struct {
        URL       string `json:"url,omitempty"`
        Hostname  string `json:"hostname,omitempty"`
        SpamCheck bool   `json:"spam_check"`
        SendRaw   bool   `json:"send_raw"`
}

type OutputCreateInboundParseWebhook struct {
        URL       string `json:"url,omitempty"`
        Hostname  string `json:"hostname,omitempty"`
        SpamCheck bool   `json:"spam_check,omitempty"`
        SendRaw   bool   `json:"send_raw,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/settings-inbound-parse/create-a-parse-setting
func (c *Client) CreateInboundParseWebhook(ctx context.Context, input *InputCreateInboundParseWebhook) (*OutputCreateInboundParseWebhook, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("POST", "/user/webhooks/parse/settings", input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputCreateInboundParseWebhook)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateInboundParseWebhook struct {
        URL       string `json:"url,omitempty"`
        SpamCheck bool   `json:"spam_check"`
        SendRaw   bool   `json:"send_raw"`
}

type OutputUpdateInboundParseWebhook struct {
        URL       string `json:"url,omitempty"`
        Hostname  string `json:"hostname,omitempty"`
        SpamCheck bool   `json:"spam_check,omitempty"`
        SendRaw   bool   `json:"send_raw,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/settings-inbound-parse/update-a-parse-setting
func (c *Client) UpdateInboundParseWebhook(ctx context.Context, hostname string, input *InputUpdateInboundParseWebhook) (*OutputUpdateInboundParseWebhook, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/user/webhooks/parse/settings/%s", hostname)

        req, err := c.NewRequest("PATCH", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateInboundParseWebhook)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

// see: https://docs.sendgrid.com/api-reference/settings-inbound-parse/delete-a-parse-setting
func (c *Client) DeleteInboundParseWebhook(ctx context.Context, hostname string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/user/webhooks/parse/settings/%s", hostname)

        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package sendgrid

import (
        "context"
        "fmt"
        "net/url"
)

// IPAddress represents an IP address
type IPAddress struct {
        IP         string   `json:"ip,omitempty"`
        Pools      []string `json:"pools,omitempty"`
        Warmup     bool     `json:"warmup,omitempty"`
        StartDate  int64    `json:"start_date,omitempty"`
        Subusers   []string `json:"subusers,omitempty"`
        Rdns       string   `json:"rdns,omitempty"`
        AssignedAt int64    `json:"assigned_at,omitempty"`
}

// IPPool represents an IP pool
type IPPool struct {
        Name string `json:"name,omitempty"`
}

// IPWarmupStatus represents IP warmup status
type IPWarmupStatus struct {
        IP     string `json:"ip,omitempty"`
        Warmup bool   `json:"warmup,omitempty"`
}

// InputAddIPToPool represents the request to add an IP to a pool
type InputAddIPToPool struct {
        IP string `json:"ip"`
}

// InputAssignIPToSubuser represents the request to assign an IP to a subuser
type InputAssignIPToSubuser struct {
        IPs []string `json:"ips"`
}

// OutputAssignedIPs represents the response for assigned IPs
type OutputAssignedIPs struct {
        IPs []string `json:"ips,omitempty"`
}

// GetIPAddresses retrieves all IP addresses
// see: https://www.twilio.com/docs/sendgrid/api-reference/ip-addresses/retrieve-all-ip-addresses
func (c *Client) GetIPAddresses(ctx context.Context) ([]IPAddress, error) <span class="cov8" title="1">{
        path := "/ips"

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var ips []IPAddress
        if err := c.Do(ctx, req, &amp;ips); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return ips, nil</span>
}

// GetAssignedIPAddresses retrieves all assigned IP addresses
// see: https://www.twilio.com/docs/sendgrid/api-reference/ip-addresses/retrieve-all-assigned-ips
func (c *Client) GetAssignedIPAddresses(ctx context.Context) ([]IPAddress, error) <span class="cov8" title="1">{
        path := "/ips/assigned"

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var ips []IPAddress
        if err := c.Do(ctx, req, &amp;ips); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return ips, nil</span>
}

// GetRemainingIPCount retrieves remaining IP count
// see: https://www.twilio.com/docs/sendgrid/api-reference/ip-addresses/retrieve-remaining-ip-count
func (c *Client) GetRemainingIPCount(ctx context.Context) (map[string]interface{}, error) <span class="cov8" title="1">{
        path := "/ips/remaining"

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var result map[string]interface{}
        if err := c.Do(ctx, req, &amp;result); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// GetIPAddress retrieves a specific IP address
// see: https://www.twilio.com/docs/sendgrid/api-reference/ip-addresses/retrieve-an-ip-address
func (c *Client) GetIPAddress(ctx context.Context, ip string) (*IPAddress, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/ips/%s", url.QueryEscape(ip))

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var ipAddr IPAddress
        if err := c.Do(ctx, req, &amp;ipAddr); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;ipAddr, nil</span>
}

// GetIPPools retrieves all IP pools
// see: https://www.twilio.com/docs/sendgrid/api-reference/ip-pools/retrieve-all-ip-pools
func (c *Client) GetIPPools(ctx context.Context) ([]IPPool, error) <span class="cov8" title="1">{
        path := "/ips/pools"

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var pools []IPPool
        if err := c.Do(ctx, req, &amp;pools); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return pools, nil</span>
}

// CreateIPPool creates an IP pool
// see: https://www.twilio.com/docs/sendgrid/api-reference/ip-pools/create-an-ip-pool
func (c *Client) CreateIPPool(ctx context.Context, name string) (*IPPool, error) <span class="cov8" title="1">{
        path := "/ips/pools"

        input := &amp;IPPool{Name: name}

        req, err := c.NewRequest("POST", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var pool IPPool
        if err := c.Do(ctx, req, &amp;pool); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;pool, nil</span>
}

// GetIPPool retrieves a specific IP pool
// see: https://www.twilio.com/docs/sendgrid/api-reference/ip-pools/retrieve-an-ip-pool
func (c *Client) GetIPPool(ctx context.Context, name string) (*IPPool, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/ips/pools/%s", url.QueryEscape(name))

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var pool IPPool
        if err := c.Do(ctx, req, &amp;pool); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;pool, nil</span>
}

// UpdateIPPool updates an IP pool name
// see: https://www.twilio.com/docs/sendgrid/api-reference/ip-pools/update-an-ip-pool
func (c *Client) UpdateIPPool(ctx context.Context, oldName, newName string) (*IPPool, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/ips/pools/%s", url.QueryEscape(oldName))

        input := &amp;IPPool{Name: newName}

        req, err := c.NewRequest("PUT", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var pool IPPool
        if err := c.Do(ctx, req, &amp;pool); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;pool, nil</span>
}

// DeleteIPPool deletes an IP pool
// see: https://www.twilio.com/docs/sendgrid/api-reference/ip-pools/delete-an-ip-pool
func (c *Client) DeleteIPPool(ctx context.Context, name string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/ips/pools/%s", url.QueryEscape(name))

        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// AddIPToPool adds an IP address to a pool
// see: https://www.twilio.com/docs/sendgrid/api-reference/ip-pools/add-an-ip-address-to-a-pool
func (c *Client) AddIPToPool(ctx context.Context, poolName, ip string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/ips/pools/%s/ips", url.QueryEscape(poolName))

        input := &amp;InputAddIPToPool{IP: ip}

        req, err := c.NewRequest("POST", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RemoveIPFromPool removes an IP address from a pool
// see: https://www.twilio.com/docs/sendgrid/api-reference/ip-pools/remove-an-ip-address-from-a-pool
func (c *Client) RemoveIPFromPool(ctx context.Context, poolName, ip string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/ips/pools/%s/ips/%s", url.QueryEscape(poolName), url.QueryEscape(ip))

        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// StartIPWarmup starts IP warmup process
// see: https://www.twilio.com/docs/sendgrid/api-reference/ip-warmup/start-ip-warmup
func (c *Client) StartIPWarmup(ctx context.Context, ip string) (*IPWarmupStatus, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/ips/warmup/%s", url.QueryEscape(ip))

        req, err := c.NewRequest("POST", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var status IPWarmupStatus
        if err := c.Do(ctx, req, &amp;status); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;status, nil</span>
}

// StopIPWarmup stops IP warmup process
// see: https://www.twilio.com/docs/sendgrid/api-reference/ip-warmup/stop-ip-warmup
func (c *Client) StopIPWarmup(ctx context.Context, ip string) (*IPWarmupStatus, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/ips/warmup/%s", url.QueryEscape(ip))

        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var status IPWarmupStatus
        if err := c.Do(ctx, req, &amp;status); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;status, nil</span>
}

// GetIPWarmupStatus retrieves IP warmup status
// see: https://www.twilio.com/docs/sendgrid/api-reference/ip-warmup/retrieve-ip-warmup-status
func (c *Client) GetIPWarmupStatus(ctx context.Context, ip string) (*IPWarmupStatus, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/ips/warmup/%s", url.QueryEscape(ip))

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var status IPWarmupStatus
        if err := c.Do(ctx, req, &amp;status); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;status, nil</span>
}

// GetAllIPWarmupStatus retrieves all IP warmup statuses
// see: https://www.twilio.com/docs/sendgrid/api-reference/ip-warmup/retrieve-all-ip-warmup-statuses
func (c *Client) GetAllIPWarmupStatus(ctx context.Context) ([]IPWarmupStatus, error) <span class="cov8" title="1">{
        path := "/ips/warmup"

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var statuses []IPWarmupStatus
        if err := c.Do(ctx, req, &amp;statuses); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return statuses, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package sendgrid

import (
        "context"
        "fmt"
        "net/url"
        "strconv"
)

type OutputGetBrandedLink struct {
        ID        int64          `json:"id,omitempty"`
        Domain    string         `json:"domain,omitempty"`
        Subdomain string         `json:"subdomain,omitempty"`
        Username  string         `json:"username,omitempty"`
        UserID    int64          `json:"user_id,omitempty"`
        Default   bool           `json:"default,omitempty"`
        Valid     bool           `json:"valid,omitempty"`
        Legacy    bool           `json:"legacy,omitempty"`
        DNS       DNSBrandedLink `json:"dns,omitempty"`
}

type DNSBrandedLink struct {
        DomainCname Record `json:"domain_cname,omitempty"`
        OwnerCname  Record `json:"owner_cname,omitempty"`
}

func (c *Client) GetBrandedLink(ctx context.Context, id int64) (*OutputGetBrandedLink, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/links/%s", strconv.FormatInt(id, 10))
        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetBrandedLink)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

type OutputGetDefaultBrandedLink struct {
        ID        int64          `json:"id,omitempty"`
        Domain    string         `json:"domain,omitempty"`
        Subdomain string         `json:"subdomain,omitempty"`
        Username  string         `json:"username,omitempty"`
        UserID    int64          `json:"user_id,omitempty"`
        Default   bool           `json:"default,omitempty"`
        Valid     bool           `json:"valid,omitempty"`
        Legacy    bool           `json:"legacy,omitempty"`
        DNS       DNSBrandedLink `json:"dns,omitempty"`
}

func (c *Client) GetDefaultBrandedLink(ctx context.Context) (*OutputGetDefaultBrandedLink, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("GET", "/whitelabel/links/default", nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetDefaultBrandedLink)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

type InputGetBrandedLinks struct {
        Limit int
}

type BrandedLink struct {
        ID        int64          `json:"id,omitempty"`
        Domain    string         `json:"domain,omitempty"`
        Subdomain string         `json:"subdomain,omitempty"`
        Username  string         `json:"username,omitempty"`
        UserID    int64          `json:"user_id,omitempty"`
        Default   bool           `json:"default,omitempty"`
        Valid     bool           `json:"valid,omitempty"`
        Legacy    bool           `json:"legacy,omitempty"`
        DNS       DNSBrandedLink `json:"dns,omitempty"`
}

func (c *Client) GetBrandedLinks(ctx context.Context, input *InputGetBrandedLinks) ([]*BrandedLink, error) <span class="cov8" title="1">{
        u, err := url.Parse("/whitelabel/links")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">q := u.Query()
        if input.Limit &gt; 0 </span><span class="cov8" title="1">{
                q.Set("limit", strconv.Itoa(input.Limit))
        }</span>
        <span class="cov8" title="1">u.RawQuery = q.Encode()

        req, err := c.NewRequest("GET", u.String(), nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := []*BrandedLink{}
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

type OutputGetSubuserBrandedLink struct {
        ID        int64          `json:"id,omitempty"`
        Domain    string         `json:"domain,omitempty"`
        Subdomain string         `json:"subdomain,omitempty"`
        Username  string         `json:"username,omitempty"`
        UserID    int64          `json:"user_id,omitempty"`
        Default   bool           `json:"default,omitempty"`
        Valid     bool           `json:"valid,omitempty"`
        Legacy    bool           `json:"legacy,omitempty"`
        DNS       DNSBrandedLink `json:"dns,omitempty"`
}

func (c *Client) GetSubuserBrandedLink(ctx context.Context, subuser string) (*OutputGetSubuserBrandedLink, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/links/subuser?username=%s", subuser)
        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetSubuserBrandedLink)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

type InputCreateBrandedLink struct {
        Domain    string `json:"domain,omitempty"`
        Subdomain string `json:"subdomain,omitempty"`
        Default   bool   `json:"default"`
}

type OutputCreateBrandedLink struct {
        ID        int64          `json:"id,omitempty"`
        Domain    string         `json:"domain,omitempty"`
        Subdomain string         `json:"subdomain,omitempty"`
        Username  string         `json:"username,omitempty"`
        UserID    int64          `json:"user_id,omitempty"`
        Default   bool           `json:"default,omitempty"`
        Valid     bool           `json:"valid,omitempty"`
        Legacy    bool           `json:"legacy,omitempty"`
        DNS       DNSBrandedLink `json:"dns,omitempty"`
}

func (c *Client) CreateBrandedLink(ctx context.Context, input *InputCreateBrandedLink) (*OutputCreateBrandedLink, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("POST", "/whitelabel/links", input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputCreateBrandedLink)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

type OutputValidateBrandedLink struct {
        ID                int64                        `json:"id,omitempty"`
        Valid             bool                         `json:"valid,omitempty"`
        ValidationResults ValidationResultsBrandedLink `json:"validation_results,omitempty"`
}

type ValidationResultsBrandedLink struct {
        DomainCname ValidationResult `json:"domain_cname,omitempty"`
        OwnerCname  ValidationResult `json:"owner_cname,omitempty"`
}

func (c *Client) ValidateBrandedLink(ctx context.Context, id int64) (*OutputValidateBrandedLink, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/links/%s/validate", strconv.FormatInt(id, 10))
        req, err := c.NewRequest("POST", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputValidateBrandedLink)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

type InputAssociateBrandedLinkWithSubuser struct {
        Username string `json:"username,omitempty"`
}

type OutputAssociateBrandedLinkWithSubuser struct {
        ID        int64          `json:"id,omitempty"`
        Domain    string         `json:"domain,omitempty"`
        Subdomain string         `json:"subdomain,omitempty"`
        Username  string         `json:"username,omitempty"`
        UserID    int64          `json:"user_id,omitempty"`
        Default   bool           `json:"default,omitempty"`
        Valid     bool           `json:"valid,omitempty"`
        Legacy    bool           `json:"legacy,omitempty"`
        DNS       DNSBrandedLink `json:"dns,omitempty"`
}

func (c *Client) AssociateBrandedLinkWithSubuser(ctx context.Context, id int64, input *InputAssociateBrandedLinkWithSubuser) (*OutputAssociateBrandedLinkWithSubuser, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/links/%s/subuser", strconv.FormatInt(id, 10))
        req, err := c.NewRequest("POST", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputAssociateBrandedLinkWithSubuser)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

func (c *Client) DisassociateBrandedLinkWithSubuser(ctx context.Context, username string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/links/subuser?username=%s", username)
        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type InputUpdateBrandedLink struct {
        Default bool `json:"default"`
}

type OutputUpdateBrandedLink struct {
        ID        int64          `json:"id,omitempty"`
        Domain    string         `json:"domain,omitempty"`
        Subdomain string         `json:"subdomain,omitempty"`
        Username  string         `json:"username,omitempty"`
        UserID    int64          `json:"user_id,omitempty"`
        Default   bool           `json:"default,omitempty"`
        Valid     bool           `json:"valid,omitempty"`
        Legacy    bool           `json:"legacy,omitempty"`
        DNS       DNSBrandedLink `json:"dns,omitempty"`
}

func (c *Client) UpdateBrandedLink(ctx context.Context, id int64, input *InputUpdateBrandedLink) (*OutputUpdateBrandedLink, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/links/%s", strconv.FormatInt(id, 10))
        req, err := c.NewRequest("PATCH", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateBrandedLink)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

func (c *Client) DeleteBrandedLink(ctx context.Context, id int64) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/links/%s", strconv.FormatInt(id, 10))
        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package sendgrid

import (
        "fmt"
        "log"
)

var logFatal = log.Fatal

type logger interface {
        Output(int, string) error
}

// ilogger represents the internal logging api we use.
type ilogger interface {
        logger
        Print(...interface{})
        Printf(string, ...interface{})
        Println(...interface{})
}

type debug interface {
        Debug() bool

        // Debugf print a formatted debug line.
        Debugf(format string, v ...interface{})
        // Debugln print a debug line.
        Debugln(v ...interface{})
}

// internalLog implements the additional methods used by our internal logging.
type internalLog struct {
        logger
}

// Println replicates the behaviour of the standard logger.
func (t internalLog) Println(v ...interface{}) <span class="cov8" title="1">{
        if err := t.Output(2, fmt.Sprintln(v...)); err != nil </span><span class="cov8" title="1">{
                logFatal(err)
        }</span>
}

// Printf replicates the behaviour of the standard logger.
func (t internalLog) Printf(format string, v ...interface{}) <span class="cov8" title="1">{
        if err := t.Output(2, fmt.Sprintf(format, v...)); err != nil </span><span class="cov8" title="1">{
                logFatal(err)
        }</span>
}

// Print replicates the behaviour of the standard logger.
func (t internalLog) Print(v ...interface{}) <span class="cov8" title="1">{
        if err := t.Output(2, fmt.Sprint(v...)); err != nil </span><span class="cov8" title="1">{
                logFatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package sendgrid

import (
        "context"
        "time"
)

// Email represents an email address with optional name
type Email struct {
        Email string `json:"email"`
        Name  string `json:"name,omitempty"`
}

// Content represents email content with type and value
type Content struct {
        Type  string `json:"type"`
        Value string `json:"value"`
}

// Attachment represents an email attachment
type Attachment struct {
        Content     string `json:"content"`
        Type        string `json:"type,omitempty"`
        Filename    string `json:"filename"`
        Disposition string `json:"disposition,omitempty"`
        ContentID   string `json:"content_id,omitempty"`
}

// Personalization contains personalized data for recipients
type Personalization struct {
        To                  []*Email               `json:"to,omitempty"`
        Cc                  []*Email               `json:"cc,omitempty"`
        Bcc                 []*Email               `json:"bcc,omitempty"`
        Subject             string                 `json:"subject,omitempty"`
        Headers             map[string]string      `json:"headers,omitempty"`
        Substitutions       map[string]string      `json:"substitutions,omitempty"`
        DynamicTemplateData map[string]interface{} `json:"dynamic_template_data,omitempty"`
        CustomArgs          map[string]string      `json:"custom_args,omitempty"`
        SendAt              int64                  `json:"send_at,omitempty"`
}

// MailSettings contains various mail settings
type MailSettings struct {
        BypassListManagement        *Setting          `json:"bypass_list_management,omitempty"`
        BypassSpamManagement        *Setting          `json:"bypass_spam_management,omitempty"`
        BypassBounceManagement      *Setting          `json:"bypass_bounce_management,omitempty"`
        BypassUnsubscribeManagement *Setting          `json:"bypass_unsubscribe_management,omitempty"`
        Footer                      *FooterSetting    `json:"footer,omitempty"`
        SandBoxMode                 *Setting          `json:"sandbox_mode,omitempty"`
        SpamCheck                   *SpamCheckSetting `json:"spam_check,omitempty"`
}

// Setting represents a boolean setting
type Setting struct {
        Enable *bool `json:"enable,omitempty"`
}

// FooterSetting represents footer settings
type FooterSetting struct {
        Enable *bool  `json:"enable,omitempty"`
        Text   string `json:"text,omitempty"`
        HTML   string `json:"html,omitempty"`
}

// SpamCheckSetting represents spam check settings
type SpamCheckSetting struct {
        Enable    *bool  `json:"enable,omitempty"`
        Threshold int    `json:"threshold,omitempty"`
        PostToURL string `json:"post_to_url,omitempty"`
}

// TrackingSettings contains various tracking settings
type TrackingSettings struct {
        ClickTracking        *ClickTrackingSetting        `json:"click_tracking,omitempty"`
        OpenTracking         *OpenTrackingSetting         `json:"open_tracking,omitempty"`
        SubscriptionTracking *SubscriptionTrackingSetting `json:"subscription_tracking,omitempty"`
        GoogleAnalytics      *GoogleAnalyticsSetting      `json:"ganalytics,omitempty"`
}

// ClickTrackingSetting represents click tracking settings
type ClickTrackingSetting struct {
        Enable     *bool `json:"enable,omitempty"`
        EnableText *bool `json:"enable_text,omitempty"`
}

// OpenTrackingSetting represents open tracking settings
type OpenTrackingSetting struct {
        Enable          *bool  `json:"enable,omitempty"`
        SubstitutionTag string `json:"substitution_tag,omitempty"`
}

// SubscriptionTrackingSetting represents subscription tracking settings
type SubscriptionTrackingSetting struct {
        Enable          *bool  `json:"enable,omitempty"`
        Text            string `json:"text,omitempty"`
        HTML            string `json:"html,omitempty"`
        SubstitutionTag string `json:"substitution_tag,omitempty"`
}

// GoogleAnalyticsSetting represents Google Analytics settings
type GoogleAnalyticsSetting struct {
        Enable      *bool  `json:"enable,omitempty"`
        UTMSource   string `json:"utm_source,omitempty"`
        UTMMedium   string `json:"utm_medium,omitempty"`
        UTMTerm     string `json:"utm_term,omitempty"`
        UTMContent  string `json:"utm_content,omitempty"`
        UTMCampaign string `json:"utm_campaign,omitempty"`
}

// ReplyTo represents reply-to settings
type ReplyTo struct {
        Email string `json:"email"`
        Name  string `json:"name,omitempty"`
}

// ReplyToList represents a list of reply-to addresses
type ReplyToList struct {
        Email string `json:"email"`
        Name  string `json:"name,omitempty"`
}

// InputSendMail represents the request body for sending mail
type InputSendMail struct {
        Personalizations []*Personalization `json:"personalizations"`
        From             *Email             `json:"from"`
        ReplyTo          *ReplyTo           `json:"reply_to,omitempty"`
        ReplyToList      []*ReplyToList     `json:"reply_to_list,omitempty"`
        Subject          string             `json:"subject,omitempty"`
        Content          []*Content         `json:"content,omitempty"`
        Attachments      []*Attachment      `json:"attachments,omitempty"`
        TemplateID       string             `json:"template_id,omitempty"`
        Headers          map[string]string  `json:"headers,omitempty"`
        Categories       []string           `json:"categories,omitempty"`
        CustomArgs       map[string]string  `json:"custom_args,omitempty"`
        SendAt           int64              `json:"send_at,omitempty"`
        BatchID          string             `json:"batch_id,omitempty"`
        ASM              *ASM               `json:"asm,omitempty"`
        IPPoolName       string             `json:"ip_pool_name,omitempty"`
        MailSettings     *MailSettings      `json:"mail_settings,omitempty"`
        TrackingSettings *TrackingSettings  `json:"tracking_settings,omitempty"`
}

// ASM represents Advanced Suppression Manager settings
type ASM struct {
        GroupID         int   `json:"group_id"`
        GroupsToDisplay []int `json:"groups_to_display,omitempty"`
}

// OutputSendMail represents the response from sending mail
type OutputSendMail struct {
        MessageID string `json:"message-id,omitempty"`
}

// NewEmail creates a new Email struct
func NewEmail(email, name string) *Email <span class="cov8" title="1">{
        return &amp;Email{
                Email: email,
                Name:  name,
        }
}</span>

// NewContent creates a new Content struct
func NewContent(contentType, value string) *Content <span class="cov8" title="1">{
        return &amp;Content{
                Type:  contentType,
                Value: value,
        }
}</span>

// NewPersonalization creates a new Personalization struct
func NewPersonalization() *Personalization <span class="cov8" title="1">{
        return &amp;Personalization{}
}</span>

// AddTo adds a recipient to personalization
func (p *Personalization) AddTo(email *Email) <span class="cov8" title="1">{
        p.To = append(p.To, email)
}</span>

// AddCc adds a CC recipient to personalization
func (p *Personalization) AddCc(email *Email) <span class="cov8" title="1">{
        p.Cc = append(p.Cc, email)
}</span>

// AddBcc adds a BCC recipient to personalization
func (p *Personalization) AddBcc(email *Email) <span class="cov8" title="1">{
        p.Bcc = append(p.Bcc, email)
}</span>

// SetSendAt sets the send time for personalization
func (p *Personalization) SetSendAt(sendAt time.Time) <span class="cov8" title="1">{
        p.SendAt = sendAt.Unix()
}</span>

// NewInputSendMail creates a new InputSendMail struct
func NewInputSendMail() *InputSendMail <span class="cov8" title="1">{
        return &amp;InputSendMail{}
}</span>

// SetFrom sets the from email address
func (m *InputSendMail) SetFrom(from *Email) <span class="cov8" title="1">{
        m.From = from
}</span>

// SetSubject sets the email subject
func (m *InputSendMail) SetSubject(subject string) <span class="cov8" title="1">{
        m.Subject = subject
}</span>

// AddPersonalization adds a personalization to the mail
func (m *InputSendMail) AddPersonalization(personalization *Personalization) <span class="cov8" title="1">{
        m.Personalizations = append(m.Personalizations, personalization)
}</span>

// AddContent adds content to the mail
func (m *InputSendMail) AddContent(content *Content) <span class="cov8" title="1">{
        m.Content = append(m.Content, content)
}</span>

// AddAttachment adds an attachment to the mail
func (m *InputSendMail) AddAttachment(attachment *Attachment) <span class="cov8" title="1">{
        m.Attachments = append(m.Attachments, attachment)
}</span>

// SetTemplateID sets the template ID for the mail
func (m *InputSendMail) SetTemplateID(templateID string) <span class="cov8" title="1">{
        m.TemplateID = templateID
}</span>

// SetSendAt sets the send time for the mail
func (m *InputSendMail) SetSendAt(sendAt time.Time) <span class="cov8" title="1">{
        m.SendAt = sendAt.Unix()
}</span>

// AddCategory adds a category to the mail
func (m *InputSendMail) AddCategory(category string) <span class="cov8" title="1">{
        m.Categories = append(m.Categories, category)
}</span>

// SendMail sends an email using SendGrid's mail/send API
// see: https://www.twilio.com/docs/sendgrid/api-reference/mail-send/mail-send
func (c *Client) SendMail(ctx context.Context, input *InputSendMail) (*OutputSendMail, error) <span class="cov8" title="1">{
        path := "/mail/send"

        req, err := c.NewRequest("POST", path, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputSendMail)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package sendgrid

import (
        "encoding/json"
        "fmt"
        "net/http"
        "net/http/httputil"
        "strconv"
        "strings"
        "time"

        "github.com/pkg/errors"
)

// ErrorResponse is sendgrid error response
type ErrorResponse struct {
        Error string `json:"error"`
}

// Err : error
func (t ErrorResponse) Err() error <span class="cov8" title="1">{
        if len(t.Error) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return errors.New(t.Error)</span>
}

// ErrorsResponse is sendgrid error response
type ErrorsResponse struct {
        Errors []*Error `json:"errors"`
}

type RateLimitedError struct {
        RetryAfter time.Duration
}

func (e *RateLimitedError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("sendgrid rate limit exceeded, retry after %s", e.RetryAfter)
}</span>

// Error is sendgrid error
type Error struct {
        Field   *string `json:"field,omitempty"`
        Message *string `json:"message,omitempty"`
}

// Errs : error list
func (t ErrorsResponse) Errs() error <span class="cov8" title="1">{
        s := []string{}
        for _, err := range t.Errors </span><span class="cov8" title="1">{
                var msg strings.Builder
                if err.Field != nil </span><span class="cov8" title="1">{
                        msg.WriteString("field: ")
                        msg.WriteString(*err.Field)
                        msg.WriteString(", ")
                }</span>
                <span class="cov8" title="1">msg.WriteString("message: ")
                msg.WriteString(*err.Message)
                s = append(s, msg.String())</span>
        }

        <span class="cov8" title="1">if len(s) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return errors.New(strings.Join(s, ", "))</span>
}

// StatusCodeError represents an http response error.
// type httpStatusCode interface { HTTPStatusCode() int } to handle it.
type statusCodeError struct {
        Code   int
        Status string
}

func (t statusCodeError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("sendgrid server error: %s", t.Status)
}</span>

func (t statusCodeError) HTTPStatusCode() int <span class="cov8" title="1">{
        return t.Code
}</span>

func checkStatusCode(resp *http.Response, d debug) error <span class="cov8" title="1">{
        if resp.StatusCode == http.StatusTooManyRequests </span><span class="cov8" title="1">{
                xRateLimitReset, err := strconv.ParseInt(resp.Header.Get("X-RateLimit-Reset"), 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">retryAfter := time.Until(time.Unix(xRateLimitReset, 0))
                return &amp;RateLimitedError{retryAfter}</span>
        }

        // return no error if response returns status code 2xx
        <span class="cov8" title="1">if resp.StatusCode/100 == 2 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if err := logResponse(resp, d); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // {"errors": [{"field": "field name", "message": "error message"}]}
        <span class="cov8" title="1">errorsResponse := new(ErrorsResponse)
        if err := newJSONParser(errorsResponse)(resp); err == nil </span><span class="cov8" title="1">{
                if errorsResponse.Errs() != nil </span><span class="cov8" title="1">{
                        return errorsResponse.Errs()
                }</span>
        }

        // {"error": "error message"}
        <span class="cov8" title="1">errorResponse := new(ErrorResponse)
        if err := newJSONParser(errorResponse)(resp); err == nil </span><span class="cov0" title="0">{
                if errorResponse.Err() != nil </span><span class="cov0" title="0">{
                        return errorResponse.Err()
                }</span>
        }
        <span class="cov8" title="1">return statusCodeError{Code: resp.StatusCode, Status: resp.Status}</span>
}

type responseParser func(*http.Response) error

func newJSONParser(dst interface{}) responseParser <span class="cov8" title="1">{
        return func(resp *http.Response) error </span><span class="cov8" title="1">{
                return json.NewDecoder(resp.Body).Decode(dst)
        }</span>
}

func logResponse(resp *http.Response, d debug) error <span class="cov8" title="1">{
        if d.Debug() </span><span class="cov8" title="1">{
                text, err := httputil.DumpResponse(resp, true)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">d.Debugln(string(text))</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package sendgrid

import (
        "context"
        "fmt"
        "net/url"
        "strconv"
)

type InputGetReverseDNSs struct {
        Limit  int    `json:"limit,omitempty"`
        Offset int    `json:"offset,omitempty"`
        IP     string `json:"ip,omitempty"`
}

type OutputGetReverseDNS struct {
        ID                      int64   `json:"id,omitempty"`
        IP                      string  `json:"ip,omitempty"`
        RDNS                    string  `json:"rdns,omitempty"`
        Users                   []*User `json:"users,omitempty"`
        Subdomain               string  `json:"subdomain,omitempty"`
        Domain                  string  `json:"domain,omitempty"`
        Valid                   bool    `json:"valid,omitempty"`
        Legacy                  bool    `json:"legacy,omitempty"`
        LastValidationAttemptAt int64   `json:"last_validation_attempt_at,omitempty"`
        ARecord                 ARecord `json:"a_record,omitempty"`
}

type User struct {
        Username string `json:"username,omitempty"`
        UserID   int64  `json:"user_id,omitempty"`
}

type ARecord struct {
        Valid bool   `json:"valid,omitempty"`
        Type  string `json:"type,omitempty"`
        Host  string `json:"host,omitempty"`
        Data  string `json:"data,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/reverse-dns/retrieve-all-reverse-dns-records
func (c *Client) GetReverseDNSs(ctx context.Context, input *InputGetReverseDNSs) ([]*OutputGetReverseDNS, error) <span class="cov8" title="1">{
        u, err := url.Parse("/whitelabel/ips")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">q := u.Query()
        if input.Limit &gt; 0 </span><span class="cov8" title="1">{
                q.Set("limit", strconv.Itoa(input.Limit))
        }</span>
        <span class="cov8" title="1">if input.Offset &gt; 0 </span><span class="cov8" title="1">{
                q.Set("offset", strconv.Itoa(input.Offset))
        }</span>
        <span class="cov8" title="1">if input.IP != "" </span><span class="cov8" title="1">{
                q.Set("ip", input.IP)
        }</span>
        <span class="cov8" title="1">u.RawQuery = q.Encode()

        req, err := c.NewRequest("GET", u.String(), nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := []*OutputGetReverseDNS{}
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

// see: https://docs.sendgrid.com/api-reference/reverse-dns/retrieve-a-reverse-dns-record
func (c *Client) GetReverseDNS(ctx context.Context, id int64) (*OutputGetReverseDNS, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/ips/%v", id)

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetReverseDNS)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputCreateReverseDNS struct {
        IP        string `json:"ip,omitempty"`
        Subdomain string `json:"subdomain,omitempty"`
        Domain    string `json:"domain,omitempty"`
}

type OutputCreateReverseDNS struct {
        ID                      int64   `json:"id,omitempty"`
        IP                      string  `json:"ip,omitempty"`
        RDNS                    string  `json:"rdns,omitempty"`
        Users                   []*User `json:"users,omitempty"`
        Subdomain               string  `json:"subdomain,omitempty"`
        Domain                  string  `json:"domain,omitempty"`
        Valid                   bool    `json:"valid,omitempty"`
        Legacy                  bool    `json:"legacy,omitempty"`
        LastValidationAttemptAt int64   `json:"last_validation_attempt_at,omitempty"`
        ARecord                 ARecord `json:"a_record,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/reverse-dns/set-up-reverse-dns
func (c *Client) CreateReverseDNS(ctx context.Context, input *InputCreateReverseDNS) (*OutputCreateReverseDNS, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("GET", "/whitelabel/ips", input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputCreateReverseDNS)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type OutputValidateReverseDNS struct {
        ID                int64                       `json:"id,omitempty"`
        Valid             bool                        `json:"valid,omitempty"`
        ValidationResults ValidationResultsReverseDNS `json:"validation_results,omitempty"`
}

type ValidationResultsReverseDNS struct {
        ARecordValidationResults ARecordValidationResults `json:"a_record,omitempty"`
}

type ARecordValidationResults struct {
        Valid  bool   `json:"valid,omitempty"`
        Reason string `json:"reason,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/reverse-dns/set-up-reverse-dns
func (c *Client) ValidateReverseDNS(ctx context.Context, id int64) (*OutputValidateReverseDNS, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/ips/%v/validate", id)
        req, err := c.NewRequest("POST", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputValidateReverseDNS)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

// see: https://docs.sendgrid.com/api-reference/reverse-dns/delete-a-reverse-dns-record
func (c *Client) DeleteReverseDNS(ctx context.Context, id int64) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/ips/%v", id)
        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package sendgrid

import (
        "context"
        "fmt"
        "net/url"
        "strconv"
)

type DomainAuthentication struct {
        ID                      int64                         `json:"id,omitempty"`
        UserID                  int64                         `json:"user_id,omitempty"`
        Subdomain               string                        `json:"subdomain,omitempty"`
        Domain                  string                        `json:"domain,omitempty"`
        Username                string                        `json:"username,omitempty"`
        IPs                     []string                      `json:"ips,omitempty"`
        CustomSpf               bool                          `json:"custom_spf,omitempty"`
        Default                 bool                          `json:"default,omitempty"`
        Legacy                  bool                          `json:"legacy,omitempty"`
        AutomaticSecurity       bool                          `json:"automatic_security,omitempty"`
        Valid                   bool                          `json:"valid,omitempty"`
        DNS                     DNS                           `json:"dns,omitempty"`
        Subusers                []SubuserSenderAuthentication `json:"subusers,omitempty"`
        LastValidationAttemptAt int64                         `json:"last_validation_attempt_at,omitempty"`
}

type DNS struct {
        MailCname Record `json:"mail_cname,omitempty"`
        Dkim1     Record `json:"dkim1,omitempty"`
        Dkim2     Record `json:"dkim2,omitempty"`
}

type Record struct {
        Valid bool   `json:"valid,omitempty"`
        Type  string `json:"type,omitempty"`
        Host  string `json:"host,omitempty"`
        Data  string `json:"data,omitempty"`
}

type SubuserSenderAuthentication struct {
        UserID   int64  `json:"user_id,omitempty"`
        Username string `json:"username,omitempty"`
}

type InputGetAuthenticatedDomains struct {
        Limit           int
        Offset          int
        ExcludeSubusers bool
        Username        string
        Domain          string
}

func (c *Client) GetAuthenticatedDomains(ctx context.Context, input *InputGetAuthenticatedDomains) ([]*DomainAuthentication, error) <span class="cov8" title="1">{
        u, err := url.Parse("/whitelabel/domains")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">q := u.Query()
        if input.Limit &gt; 0 </span><span class="cov8" title="1">{
                q.Set("limit", strconv.Itoa(input.Limit))
        }</span>
        <span class="cov8" title="1">if input.Offset &gt; 0 </span><span class="cov8" title="1">{
                q.Set("offset", strconv.Itoa(input.Offset))
        }</span>
        <span class="cov8" title="1">if input.ExcludeSubusers </span><span class="cov8" title="1">{
                q.Set("exclude_subusers", "true")
        }</span>
        <span class="cov8" title="1">if input.Username != "" </span><span class="cov8" title="1">{
                q.Set("username", input.Username)
        }</span>
        <span class="cov8" title="1">if input.Domain != "" </span><span class="cov8" title="1">{
                q.Set("domain", input.Domain)
        }</span>
        <span class="cov8" title="1">u.RawQuery = q.Encode()

        req, err := c.NewRequest("GET", u.String(), nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := []*DomainAuthentication{}
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputGetDefaultAuthentication struct {
        Domain string
}

type OutputGetDefaultAuthentication struct {
        ID                      int64                         `json:"id,omitempty"`
        UserID                  int64                         `json:"user_id,omitempty"`
        Subdomain               string                        `json:"subdomain,omitempty"`
        Domain                  string                        `json:"domain,omitempty"`
        Username                string                        `json:"username,omitempty"`
        IPs                     []string                      `json:"ips,omitempty"`
        CustomSpf               bool                          `json:"custom_spf,omitempty"`
        Default                 bool                          `json:"default,omitempty"`
        Legacy                  bool                          `json:"legacy,omitempty"`
        AutomaticSecurity       bool                          `json:"automatic_security,omitempty"`
        Valid                   bool                          `json:"valid,omitempty"`
        DNS                     DNS                           `json:"dns,omitempty"`
        Subusers                []SubuserSenderAuthentication `json:"subusers,omitempty"`
        LastValidationAttemptAt int64                         `json:"last_validation_attempt_at,omitempty"`
}

func (c *Client) GetDefaultAuthentication(ctx context.Context, input *InputGetDefaultAuthentication) (*OutputGetDefaultAuthentication, error) <span class="cov8" title="1">{
        u, err := url.Parse("/whitelabel/domains/default")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">q := u.Query()
        if input.Domain != "" </span><span class="cov8" title="1">{
                q.Set("domain", input.Domain)
        }</span>
        <span class="cov8" title="1">u.RawQuery = q.Encode()

        req, err := c.NewRequest("GET", u.String(), nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetDefaultAuthentication)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type OutputGetAuthenticatedDomain struct {
        ID                int64    `json:"id,omitempty"`
        UserID            int64    `json:"user_id,omitempty"`
        Subdomain         string   `json:"subdomain,omitempty"`
        Domain            string   `json:"domain,omitempty"`
        Username          string   `json:"username,omitempty"`
        IPs               []string `json:"ips,omitempty"`
        CustomSpf         bool     `json:"custom_spf,omitempty"`
        Default           bool     `json:"default,omitempty"`
        Legacy            bool     `json:"legacy,omitempty"`
        AutomaticSecurity bool     `json:"automatic_security,omitempty"`
        Valid             bool     `json:"valid,omitempty"`
        DNS               DNS      `json:"dns,omitempty"`
}

func (c *Client) GetAuthenticatedDomain(ctx context.Context, domainId int64) (*OutputGetAuthenticatedDomain, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/domains/%s", strconv.FormatInt(domainId, 10))
        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetAuthenticatedDomain)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputAuthenticateDomain struct {
        Domain             string   `json:"domain,omitempty"`
        Subdomain          string   `json:"subdomain,omitempty"`
        Username           string   `json:"username,omitempty"`
        IPs                []string `json:"ips,omitempty"`
        CustomSpf          bool     `json:"custom_spf,omitempty"`
        Default            bool     `json:"default,omitempty"`
        AutomaticSecurity  bool     `json:"automatic_security,omitempty"`
        CustomDkimSelector string   `json:"custom_dkim_selector,omitempty"`
}

type OutputAuthenticateDomain struct {
        ID                int64    `json:"id,omitempty"`
        UserID            int64    `json:"user_id,omitempty"`
        Subdomain         string   `json:"subdomain,omitempty"`
        Domain            string   `json:"domain,omitempty"`
        Username          string   `json:"username,omitempty"`
        IPs               []string `json:"ips,omitempty"`
        CustomSpf         bool     `json:"custom_spf,omitempty"`
        Default           bool     `json:"default,omitempty"`
        Legacy            bool     `json:"legacy,omitempty"`
        AutomaticSecurity bool     `json:"automatic_security,omitempty"`
        Valid             bool     `json:"valid,omitempty"`
        DNS               DNS      `json:"dns,omitempty"`
}

func (c *Client) AuthenticateDomain(ctx context.Context, input *InputAuthenticateDomain) (*OutputAuthenticateDomain, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("POST", "/whitelabel/domains", input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputAuthenticateDomain)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

type InputAddIPToAuthenticatedDomain struct {
        IP string `json:"ip,omitempty"`
}

type OutputAddIPToAuthenticatedDomain struct {
        ID                      int64    `json:"id,omitempty"`
        UserID                  int64    `json:"user_id,omitempty"`
        Subdomain               string   `json:"subdomain,omitempty"`
        Domain                  string   `json:"domain,omitempty"`
        Username                string   `json:"username,omitempty"`
        IPs                     []string `json:"ips,omitempty"`
        CustomSpf               bool     `json:"custom_spf,omitempty"`
        Default                 bool     `json:"default,omitempty"`
        Legacy                  bool     `json:"legacy,omitempty"`
        AutomaticSecurity       bool     `json:"automatic_security,omitempty"`
        Valid                   bool     `json:"valid,omitempty"`
        DNS                     DNS      `json:"dns,omitempty"`
        LastValidationAttemptAt int64    `json:"last_validation_attempt_at,omitempty"`
}

// NOTE: The 'dns' key in the API response for adding an IP to the authenticated domain is different from what is documented.
// see: https://docs.sendgrid.com/api-reference/domain-authentication/add-an-ip-to-an-authenticated-domain#responses
func (c *Client) AddIPToAuthenticatedDomain(ctx context.Context, domainId int64, input *InputAddIPToAuthenticatedDomain) (*OutputAddIPToAuthenticatedDomain, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/domains/%s/ips", strconv.FormatInt(domainId, 10))
        req, err := c.NewRequest("POST", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputAddIPToAuthenticatedDomain)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

// NOTE: The 'dns' key in the API response for removing an IP to the authenticated domain is different from what is documented.
// see: https://docs.sendgrid.com/api-reference/domain-authentication/remove-an-ip-from-an-authenticated-domain#responses
func (c *Client) RemoveIPFromAuthenticatedDomain(ctx context.Context, domainId int64, ip string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/domains/%s/ips/%s", strconv.FormatInt(domainId, 10), ip)
        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type OutputValidateDomainAuthentication struct {
        ID                int64             `json:"id,omitempty"`
        Valid             bool              `json:"valid,omitempty"`
        ValidationResults ValidationResults `json:"validation_results,omitempty"`
}

type ValidationResults struct {
        MailCname ValidationResult `json:"mail_cname,omitempty"`
        Dkim1     ValidationResult `json:"dkim1,omitempty"`
        Dkim2     ValidationResult `json:"dkim2,omitempty"`
        SPF       ValidationResult `json:"spf,omitempty"`
}

type ValidationResult struct {
        Valid  bool   `json:"valid,omitempty"`
        Reason string `json:"reason,omitempty"`
}

func (c *Client) ValidateDomainAuthentication(ctx context.Context, domainId int64) (*OutputValidateDomainAuthentication, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/domains/%s/validate", strconv.FormatInt(domainId, 10))
        req, err := c.NewRequest("POST", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputValidateDomainAuthentication)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateDomainAuthentication struct {
        Default   bool `json:"default"`
        CustomSpf bool `json:"custom_spf"`
}

type OutputUpdateDomainAuthentication struct {
        ID                      int64                         `json:"id,omitempty"`
        UserID                  int64                         `json:"user_id,omitempty"`
        Subdomain               string                        `json:"subdomain,omitempty"`
        Domain                  string                        `json:"domain,omitempty"`
        Username                string                        `json:"username,omitempty"`
        IPs                     []string                      `json:"ips,omitempty"`
        CustomSpf               bool                          `json:"custom_spf,omitempty"`
        Default                 bool                          `json:"default,omitempty"`
        Legacy                  bool                          `json:"legacy,omitempty"`
        AutomaticSecurity       bool                          `json:"automatic_security,omitempty"`
        Valid                   bool                          `json:"valid,omitempty"`
        DNS                     DNS                           `json:"dns,omitempty"`
        Subusers                []SubuserSenderAuthentication `json:"subusers,omitempty"`
        LastValidationAttemptAt int64                         `json:"last_validation_attempt_at,omitempty"`
}

func (c *Client) UpdateDomainAuthentication(ctx context.Context, domainId int64, input *InputUpdateDomainAuthentication) (*OutputUpdateDomainAuthentication, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/domains/%s", strconv.FormatInt(domainId, 10))
        req, err := c.NewRequest("PATCH", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateDomainAuthentication)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

func (c *Client) DeleteAuthenticatedDomain(ctx context.Context, domainId int64) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/domains/%s", strconv.FormatInt(domainId, 10))
        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type OutputGetAuthenticatedDomainAssociatedWithSubuser struct {
        ID                      int64    `json:"id,omitempty"`
        UserID                  int64    `json:"user_id,omitempty"`
        Subdomain               string   `json:"subdomain,omitempty"`
        Domain                  string   `json:"domain,omitempty"`
        Username                string   `json:"username,omitempty"`
        IPs                     []string `json:"ips,omitempty"`
        CustomSpf               bool     `json:"custom_spf,omitempty"`
        Default                 bool     `json:"default,omitempty"`
        Legacy                  bool     `json:"legacy,omitempty"`
        AutomaticSecurity       bool     `json:"automatic_security,omitempty"`
        Valid                   bool     `json:"valid,omitempty"`
        DNS                     DNS      `json:"dns,omitempty"`
        LastValidationAttemptAt int64    `json:"last_validation_attempt_at,omitempty"`
}

func (c *Client) GetAuthenticatedDomainAssociatedWithSubuser(ctx context.Context, subuserName string) (*OutputGetAuthenticatedDomainAssociatedWithSubuser, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/domains/subuser?username=%s", subuserName)

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetAuthenticatedDomainAssociatedWithSubuser)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

type InputAssociateAuthenticatedDomainWithSubuser struct {
        Username string `json:"username,omitempty"`
}

type OutputAssociateAuthenticatedDomainWithSubuser struct {
        ID                      int64    `json:"id,omitempty"`
        UserID                  int64    `json:"user_id,omitempty"`
        Subdomain               string   `json:"subdomain,omitempty"`
        Domain                  string   `json:"domain,omitempty"`
        Username                string   `json:"username,omitempty"`
        IPs                     []string `json:"ips,omitempty"`
        CustomSpf               bool     `json:"custom_spf,omitempty"`
        Default                 bool     `json:"default,omitempty"`
        Legacy                  bool     `json:"legacy,omitempty"`
        AutomaticSecurity       bool     `json:"automatic_security,omitempty"`
        Valid                   bool     `json:"valid,omitempty"`
        DNS                     DNS      `json:"dns,omitempty"`
        LastValidationAttemptAt int64    `json:"last_validation_attempt_at,omitempty"`
}

func (c *Client) AssociateAuthenticatedDomainWithSubuser(ctx context.Context, domainId int64, input *InputAssociateAuthenticatedDomainWithSubuser) (*OutputAssociateAuthenticatedDomainWithSubuser, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/domains/%s/subuser", strconv.FormatInt(domainId, 10))
        req, err := c.NewRequest("POST", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputAssociateAuthenticatedDomainWithSubuser)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

func (c *Client) DisassociateAuthenticatedDomainFromSubuser(ctx context.Context, subuserName string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/whitelabel/domains/subuser?username=%s", subuserName)

        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package sendgrid

import (
        "context"
        "fmt"
        "net/url"
        "strconv"
)

type VerifiedSender struct {
        ID          int64  `json:"id,omitempty"`
        Nickname    string `json:"nickname,omitempty"`
        FromEmail   string `json:"from_email,omitempty"`
        FromName    string `json:"from_name,omitempty"`
        ReplyTo     string `json:"reply_to,omitempty"`
        ReplyToName string `json:"reply_to_name,omitempty"`
        Address     string `json:"address,omitempty"`
        Address2    string `json:"address2,omitempty"`
        State       string `json:"state,omitempty"`
        City        string `json:"city,omitempty"`
        Zip         string `json:"zip,omitempty"`
        Country     string `json:"country,omitempty"`
        Verified    bool   `json:"verified,omitempty"`
        Locked      bool   `json:"locked,omitempty"`
}

type InputGetVerifiedSenders struct {
        Limit      int
        LastSeenID int
        ID         int64
}

type OutputGetVerifiedSenders struct {
        VerifiedSenders []*VerifiedSender `json:"results,omitempty"`
}

func (c *Client) GetVerifiedSenders(ctx context.Context, input *InputGetVerifiedSenders) ([]*VerifiedSender, error) <span class="cov8" title="1">{
        u, err := url.Parse("/verified_senders")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">q := u.Query()
        if input.Limit &gt; 0 </span><span class="cov8" title="1">{
                q.Set("limit", strconv.Itoa(input.Limit))
        }</span>
        <span class="cov8" title="1">if input.LastSeenID &gt; 0 </span><span class="cov8" title="1">{
                q.Set("lastSeenID", strconv.Itoa(input.LastSeenID))
        }</span>
        <span class="cov8" title="1">if input.ID &gt; 0 </span><span class="cov8" title="1">{
                q.Set("id", strconv.FormatInt(input.ID, 10))
        }</span>
        <span class="cov8" title="1">u.RawQuery = q.Encode()

        req, err := c.NewRequest("GET", u.String(), nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetVerifiedSenders)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r.VerifiedSenders, nil</span>
}

type InputCreateVerifiedSenderRequest struct {
        Nickname    string `json:"nickname,omitempty"`
        FromEmail   string `json:"from_email,omitempty"`
        FromName    string `json:"from_name,omitempty"`
        ReplyTo     string `json:"reply_to,omitempty"`
        ReplyToName string `json:"reply_to_name,omitempty"`
        Address     string `json:"address,omitempty"`
        Address2    string `json:"address2,omitempty"`
        State       string `json:"state,omitempty"`
        City        string `json:"city,omitempty"`
        Zip         string `json:"zip,omitempty"`
        Country     string `json:"country,omitempty"`
}

type OutputCreateVerifiedSenderRequest struct {
        ID          int64  `json:"id,omitempty"`
        Nickname    string `json:"nickname,omitempty"`
        FromEmail   string `json:"from_email,omitempty"`
        FromName    string `json:"from_name,omitempty"`
        ReplyTo     string `json:"reply_to,omitempty"`
        ReplyToName string `json:"reply_to_name,omitempty"`
        Address     string `json:"address,omitempty"`
        Address2    string `json:"address2,omitempty"`
        State       string `json:"state,omitempty"`
        City        string `json:"city,omitempty"`
        Zip         string `json:"zip,omitempty"`
        Country     string `json:"country,omitempty"`
        Verified    bool   `json:"verified,omitempty"`
        Locked      bool   `json:"locked,omitempty"`
}

func (c *Client) CreateVerifiedSenderRequest(ctx context.Context, input *InputCreateVerifiedSenderRequest) (*OutputCreateVerifiedSenderRequest, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("POST", "/verified_senders", input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputCreateVerifiedSenderRequest)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

func (c *Client) ResendVerifiedSenderRequest(ctx context.Context, id int64) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/verified_senders/resend/%s", strconv.FormatInt(id, 10))
        req, err := c.NewRequest("POST", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (c *Client) VerifySenderRequest(ctx context.Context, token string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/verified_senders/verify/%s", token)
        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type InputUpdateVerifiedSender struct {
        Nickname    string `json:"nickname,omitempty"`
        FromEmail   string `json:"from_email,omitempty"`
        FromName    string `json:"from_name,omitempty"`
        ReplyTo     string `json:"reply_to,omitempty"`
        ReplyToName string `json:"reply_to_name,omitempty"`
        Address     string `json:"address,omitempty"`
        Address2    string `json:"address2,omitempty"`
        State       string `json:"state,omitempty"`
        City        string `json:"city,omitempty"`
        Zip         string `json:"zip,omitempty"`
        Country     string `json:"country,omitempty"`
}

type OutputUpdateVerifiedSender struct {
        ID          int64  `json:"id,omitempty"`
        Nickname    string `json:"nickname,omitempty"`
        FromEmail   string `json:"from_email,omitempty"`
        FromName    string `json:"from_name,omitempty"`
        ReplyTo     string `json:"reply_to,omitempty"`
        ReplyToName string `json:"reply_to_name,omitempty"`
        Address     string `json:"address,omitempty"`
        Address2    string `json:"address2,omitempty"`
        State       string `json:"state,omitempty"`
        City        string `json:"city,omitempty"`
        Zip         string `json:"zip,omitempty"`
        Country     string `json:"country,omitempty"`
        Verified    bool   `json:"verified,omitempty"`
        Locked      bool   `json:"locked,omitempty"`
}

func (c *Client) UpdateVerifiedSender(ctx context.Context, id int64, input *InputUpdateVerifiedSender) (*OutputUpdateVerifiedSender, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/verified_senders/%s", strconv.FormatInt(id, 10))
        req, err := c.NewRequest("PATCH", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateVerifiedSender)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

func (c *Client) DeleteVerifiedSender(ctx context.Context, id int64) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/verified_senders/%s", strconv.FormatInt(id, 10))
        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type OutputCompletedStepsVerifiedSender struct {
        CompletedStepsVerifiedSender *CompletedStepsVerifiedSender `json:"results,omitempty"`
}

type CompletedStepsVerifiedSender struct {
        SenderVerified bool `json:"sender_verified,omitempty"`
        DomainVerified bool `json:"domain_verified,omitempty"`
}

func (c *Client) CompletedStepsVerifiedSender(ctx context.Context) (*CompletedStepsVerifiedSender, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("GET", "/verified_senders/steps_completed", nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputCompletedStepsVerifiedSender)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r.CompletedStepsVerifiedSender, nil</span>
}

// see: https://docs.sendgrid.com/api-reference/sender-verification/domain-warn-list
// This endpoint returns a list of domains known to implement DMARC and categorizes them by failure type — hard failure or soft failure.
// Domains listed as hard failures will not deliver mail when used as a Sender Identity due to the domain's DMARC policy settings.
func (c *Client) GetSenderVerificationDomainWarnList(ctx context.Context) (*CompletedStepsVerifiedSender, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("GET", "/verified_senders/domains", nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputCompletedStepsVerifiedSender)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r.CompletedStepsVerifiedSender, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package sendgrid

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "net/url"
        "os"
        "reflect"
        "strings"

        "github.com/google/go-querystring/query"
        "github.com/pkg/errors"
)

var defaultBaseURL, _ = url.Parse("https://api.sendgrid.com/v3")

// httpClient defines the minimal interface needed for an http.Client to be implemented.
type httpClient interface {
        Do(*http.Request) (*http.Response, error)
}

// Client : sendgrid client
type Client struct {
        apiKey     string
        baseURL    *url.URL
        debug      bool
        log        ilogger
        httpclient httpClient
        subuser    string
}

// Option defines an option for a Client
type Option func(*Client)

// OptionBaseURL - provide a custom base url to the sendgrid client.
func OptionBaseURL(endpoint string) func(*Client) <span class="cov8" title="1">{
        baseURL, _ := url.Parse(endpoint)
        return func(c *Client) </span><span class="cov8" title="1">{
                c.baseURL = baseURL
        }</span>
}

// OptionBaseURL - provide a custom base url to the sendgrid client.
func OptionSubuser(subuser string) func(*Client) <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.subuser = subuser
        }</span>
}

// OptionHTTPClient - provide a custom http client to the sendgrid client.
func OptionHTTPClient(client httpClient) func(*Client) <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.httpclient = client
        }</span>
}

// OptionDebug enable debugging for the client
func OptionDebug(b bool) func(*Client) <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.debug = b
        }</span>
}

// OptionLog set logging for client.
func OptionLog(l logger) func(*Client) <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.log = internalLog{logger: l}
        }</span>
}

// New builds a sendgrid client from the provided token, baseURL and options
func New(apiKey string, options ...Option) *Client <span class="cov8" title="1">{
        s := &amp;Client{
                apiKey:     apiKey,
                baseURL:    defaultBaseURL,
                httpclient: &amp;http.Client{},
                log:        log.New(os.Stderr, "kenzo0107/sendgrid", log.LstdFlags|log.Lshortfile),
        }

        for _, opt := range options </span><span class="cov8" title="1">{
                opt(s)
        }</span>

        <span class="cov8" title="1">return s</span>
}

// Debugf print a formatted debug line.
func (c *Client) Debugf(format string, v ...interface{}) <span class="cov8" title="1">{
        if c.debug </span><span class="cov8" title="1">{
                if err := c.log.Output(2, fmt.Sprintf(format, v...)); err != nil </span><span class="cov0" title="0">{
                        c.Debugln(err)
                }</span>
        }
}

// Debugln print a debug line.
func (c *Client) Debugln(v ...interface{}) <span class="cov8" title="1">{
        if c.debug </span><span class="cov8" title="1">{
                if err := c.log.Output(2, fmt.Sprintln(v...)); err != nil </span><span class="cov0" title="0">{
                        c.Debugln(err)
                }</span>
        }
}

// Debug returns if debug is enabled.
func (c *Client) Debug() bool <span class="cov8" title="1">{
        return c.debug
}</span>

// Bool is a helper routine that allocates a new bool value
// to store v and returns a pointer to it.
func Bool(v bool) *bool <span class="cov8" title="1">{ return &amp;v }</span>

// String is a helper routine that allocates a new string value
// to store v and returns a pointer to it.
func String(v string) *string <span class="cov8" title="1">{ return &amp;v }</span>

// NewRequest creates an API request. A relative URL can be provided in urlStr,
// in which case it is resolved relative to the BaseURL of the Client.
// Relative URLs should always be specified without a preceding slash. If
// specified, the value pointed to by body is JSON encoded and included as the
// request body.
func (c *Client) NewRequest(method, urlStr string, body interface{}) (*http.Request, error) <span class="cov8" title="1">{
        if c.baseURL == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("baseURL is nil")
        }</span>

        <span class="cov8" title="1">if strings.HasSuffix(c.baseURL.Path, "/") </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("baseURL must not have a trailing slash, but %q does", c.baseURL)
        }</span>

        <span class="cov8" title="1">u, err := c.baseURL.Parse(c.baseURL.Path + urlStr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var buf io.ReadWriter
        if body != nil </span><span class="cov8" title="1">{
                buf = &amp;bytes.Buffer{}
                enc := json.NewEncoder(buf)
                enc.SetEscapeHTML(false)
                if er := enc.Encode(body); er != nil </span><span class="cov8" title="1">{
                        return nil, er
                }</span>
        }

        <span class="cov8" title="1">req, err := http.NewRequest(method, u.String(), buf)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // set api key
        <span class="cov8" title="1">req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", c.apiKey))

        // set subuser
        if c.subuser != "" </span><span class="cov8" title="1">{
                req.Header.Set("On-Behalf-Of", c.subuser)
        }</span>

        <span class="cov8" title="1">if body != nil </span><span class="cov8" title="1">{
                req.Header.Set("Content-Type", "application/json")
        }</span>

        <span class="cov8" title="1">return req, nil</span>
}

// Do sends an API request and returns the API response. The API response is
// JSON decoded and stored in the value pointed to by v, or returned as an
// error if an API error has occurred. If v implements the io.Writer
// interface, the raw response body will be written to v, without attempting to
// first decode it. If rate limit is exceeded and reset time is in the future,
// Do returns *RateLimitError immediately without making a network API call.
//
// The provided ctx must be non-nil, if it is nil an error is returned. If it is canceled or times out,
// ctx.Err() will be returned.
func (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) error <span class="cov8" title="1">{
        if ctx == nil </span><span class="cov8" title="1">{
                return errors.New("context must be non-nil")
        }</span>

        <span class="cov8" title="1">req = req.WithContext(ctx)

        resp, err := c.httpclient.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                // If we got an error, and the context has been canceled,
                // the context's error is probably more useful.
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if er := resp.Body.Close(); er != nil </span><span class="cov0" title="0">{
                        err = er
                }</span>
        }()

        <span class="cov8" title="1">err = checkStatusCode(resp, c)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if v != nil </span><span class="cov8" title="1">{
                if w, ok := v.(io.Writer); ok </span><span class="cov8" title="1">{
                        if _, er := io.Copy(w, resp.Body); er != nil </span><span class="cov0" title="0">{
                                return er
                        }</span>
                } else<span class="cov8" title="1"> {
                        decErr := json.NewDecoder(resp.Body).Decode(v)
                        if decErr == io.EOF </span><span class="cov8" title="1">{
                                decErr = nil // ignore EOF errors caused by empty response body
                        }</span>
                        <span class="cov8" title="1">if decErr != nil </span><span class="cov0" title="0">{
                                err = decErr
                        }</span>
                }
        }

        <span class="cov8" title="1">return err</span>
}

// AddOptions adds the parameters in opt as URL query parameters to s. opt
// must be a struct whose fields may contain "url" tags.
func (c *Client) AddOptions(s string, opts interface{}) (string, error) <span class="cov8" title="1">{
        v := reflect.ValueOf(opts)
        if v.Kind() == reflect.Ptr &amp;&amp; v.IsNil() </span><span class="cov8" title="1">{
                return s, nil
        }</span>

        <span class="cov8" title="1">u, err := url.Parse(s)
        if err != nil </span><span class="cov8" title="1">{
                return s, err
        }</span>

        <span class="cov8" title="1">qs, err := query.Values(opts)
        if err != nil </span><span class="cov0" title="0">{
                return s, err
        }</span>

        <span class="cov8" title="1">u.RawQuery = qs.Encode()

        return u.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package sendgrid

import (
        "context"
        "fmt"
)

type OutputGetSSOCertificate struct {
        ID                int64  `json:"id,omitempty"`
        PublicCertificate string `json:"public_certificate,omitempty"`
        NotBefore         int64  `json:"not_before,omitempty"`
        NotAfter          int64  `json:"not_after,omitempty"`
        IntegrationID     string `json:"integration_id,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/certificates/get-an-sso-certificate
func (c *Client) GetSSOCertificate(ctx context.Context, id int64) (*OutputGetSSOCertificate, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/sso/certificates/%v", id)

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetSSOCertificate)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type SSOCertificate struct {
        ID                int64  `json:"id,omitempty"`
        PublicCertificate string `json:"public_certificate,omitempty"`
        NotBefore         int64  `json:"not_before,omitempty"`
        NotAfter          int64  `json:"not_after,omitempty"`
        IntegrationID     string `json:"integration_id,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/certificates/get-all-sso-certificates-by-integration
func (c *Client) GetSSOCertificates(ctx context.Context, integrationID string) ([]*SSOCertificate, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/sso/integrations/%s/certificates", integrationID)

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := []*SSOCertificate{}
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputCreateSSOCertificate struct {
        PublicCertificate string `json:"public_certificate,omitempty"`
        Enabled           bool   `json:"enabled"`
        IntegrationID     string `json:"integration_id,omitempty"`
}

type OutputCreateSSOCertificate struct {
        ID                int64  `json:"id,omitempty"`
        PublicCertificate string `json:"public_certificate,omitempty"`
        NotBefore         int64  `json:"not_before,omitempty"`
        NotAfter          int64  `json:"not_after,omitempty"`
        IntegrationID     string `json:"integration_id,omitempty"`
}

func (c *Client) CreateSSOCertificate(ctx context.Context, input *InputCreateSSOCertificate) (*OutputCreateSSOCertificate, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("POST", "/sso/certificates", input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputCreateSSOCertificate)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateSSOCertificate struct {
        PublicCertificate string `json:"public_certificate,omitempty"`
        Enabled           bool   `json:"enabled"`
        IntegrationID     string `json:"integration_id,omitempty"`
}

type OutputUpdateSSOCertificate struct {
        ID                int64  `json:"id,omitempty"`
        PublicCertificate string `json:"public_certificate,omitempty"`
        NotBefore         int64  `json:"not_before,omitempty"`
        NotAfter          int64  `json:"not_after,omitempty"`
        IntegrationID     string `json:"integration_id,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/certificates/update-sso-certificate
func (c *Client) UpdateSSOCertificate(ctx context.Context, id int64, input *InputUpdateSSOCertificate) (*OutputUpdateSSOCertificate, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/sso/certificates/%v", id)

        req, err := c.NewRequest("PATCH", path, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateSSOCertificate)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

// see: https://docs.sendgrid.com/api-reference/certificates/delete-an-sso-certificate
func (c *Client) DeleteSSOCertificate(ctx context.Context, id int64) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/sso/certificates/%v", id)

        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package sendgrid

import (
        "context"
        "fmt"
        "net/url"
        "strconv"
)

type OutputGetSSOIntegration struct {
        ID                   string `json:"id,omitempty"`
        Name                 string `json:"name,omitempty"`
        Enabled              bool   `json:"enabled,omitempty"`
        SigninURL            string `json:"signin_url,omitempty"`
        SignoutURL           string `json:"signout_url,omitempty"`
        EntityID             string `json:"entity_id,omitempty"`
        CompletedIntegration bool   `json:"completed_integration,omitempty"`
        LastUpdated          int64  `json:"last_updated,omitempty"`
        SingleSignonURL      string `json:"single_signon_url,omitempty"`
        AudienceURL          string `json:"audience_url,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/single-sign-on-settings/get-an-sso-integration
func (c *Client) GetSSOIntegration(ctx context.Context, id string) (*OutputGetSSOIntegration, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/sso/integrations/%s", id)

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetSSOIntegration)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputGetSSOIntegrations struct {
        Si bool `json:"si,omitempty"`
}

type SSOIntegration struct {
        ID                   string `json:"id,omitempty"`
        Name                 string `json:"name,omitempty"`
        Enabled              bool   `json:"enabled,omitempty"`
        SigninURL            string `json:"signin_url,omitempty"`
        SignoutURL           string `json:"signout_url,omitempty"`
        EntityID             string `json:"entity_id,omitempty"`
        CompletedIntegration bool   `json:"completed_integration,omitempty"`
        LastUpdated          int64  `json:"last_updated,omitempty"`
        SingleSignonURL      string `json:"single_signon_url,omitempty"`
        AudienceURL          string `json:"audience_url,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/single-sign-on-settings/get-all-sso-integrations
func (c *Client) GetSSOIntegrations(ctx context.Context, input *InputGetSSOIntegrations) ([]*SSOIntegration, error) <span class="cov8" title="1">{
        u, err := url.Parse("/sso/integrations")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">q := u.Query()
        if input.Si </span><span class="cov8" title="1">{
                q.Set("si", strconv.FormatBool(input.Si))
        }</span>

        <span class="cov8" title="1">req, err := c.NewRequest("GET", u.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := []*SSOIntegration{}
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputCreateSSOIntegration struct {
        Name                 string `json:"name,omitempty"`
        Enabled              bool   `json:"enabled"`
        SigninURL            string `json:"signin_url,omitempty"`
        SignoutURL           string `json:"signout_url,omitempty"`
        EntityID             string `json:"entity_id,omitempty"`
        CompletedIntegration bool   `json:"completed_integration"`
}

type OutputCreateSSOIntegration struct {
        ID                   string `json:"id,omitempty"`
        Name                 string `json:"name,omitempty"`
        Enabled              bool   `json:"enabled,omitempty"`
        SigninURL            string `json:"signin_url,omitempty"`
        SignoutURL           string `json:"signout_url,omitempty"`
        EntityID             string `json:"entity_id,omitempty"`
        CompletedIntegration bool   `json:"completed_integration,omitempty"`
        LastUpdated          int64  `json:"last_updated,omitempty"`
        SingleSignonURL      string `json:"single_signon_url,omitempty"`
        AudienceURL          string `json:"audience_url,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/single-sign-on-settings/create-an-sso-integration
func (c *Client) CreateSSOIntegration(ctx context.Context, input *InputCreateSSOIntegration) (*OutputCreateSSOIntegration, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("POST", "/sso/integrations", input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputCreateSSOIntegration)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateSSOIntegration struct {
        Name                 string `json:"name,omitempty"`
        Enabled              bool   `json:"enabled"`
        SigninURL            string `json:"signin_url,omitempty"`
        SignoutURL           string `json:"signout_url,omitempty"`
        EntityID             string `json:"entity_id,omitempty"`
        CompletedIntegration bool   `json:"completed_integration"`
}

type OutputUpdateSSOIntegration struct {
        ID                   string `json:"id,omitempty"`
        Name                 string `json:"name,omitempty"`
        Enabled              bool   `json:"enabled,omitempty"`
        SigninURL            string `json:"signin_url,omitempty"`
        SignoutURL           string `json:"signout_url,omitempty"`
        EntityID             string `json:"entity_id,omitempty"`
        CompletedIntegration bool   `json:"completed_integration,omitempty"`
        LastUpdated          int64  `json:"last_updated,omitempty"`
        SingleSignonURL      string `json:"single_signon_url,omitempty"`
        AudienceURL          string `json:"audience_url,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/single-sign-on-settings/update-an-sso-integration
func (c *Client) UpdateSSOIntegration(ctx context.Context, id string, input *InputUpdateSSOIntegration) (*OutputUpdateSSOIntegration, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/sso/integrations/%s", id)

        req, err := c.NewRequest("PATCH", path, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateSSOIntegration)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

// see: https://docs.sendgrid.com/api-reference/single-sign-on-settings/delete-an-sso-integration
func (c *Client) DeleteSSOIntegration(ctx context.Context, id string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/sso/integrations/%s", id)

        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package sendgrid

import (
        "context"
        "fmt"
        "strings"
)

// Stat represents statistics data
type Stat struct {
        Date  string     `json:"date,omitempty"`
        Stats []StatItem `json:"stats,omitempty"`
}

// StatItem represents individual statistic metrics
type StatItem struct {
        Metrics StatMetrics `json:"metrics,omitempty"`
        Name    string      `json:"name,omitempty"`
        Type    string      `json:"type,omitempty"`
}

// StatMetrics represents metric data
type StatMetrics struct {
        Blocks           int `json:"blocks,omitempty"`
        BounceDrops      int `json:"bounce_drops,omitempty"`
        Bounces          int `json:"bounces,omitempty"`
        Clicks           int `json:"clicks,omitempty"`
        DeferredDrops    int `json:"deferred_drops,omitempty"`
        Delivered        int `json:"delivered,omitempty"`
        InvalidEmails    int `json:"invalid_emails,omitempty"`
        Opens            int `json:"opens,omitempty"`
        Processed        int `json:"processed,omitempty"`
        Requests         int `json:"requests,omitempty"`
        SpamReportDrops  int `json:"spam_report_drops,omitempty"`
        SpamReports      int `json:"spam_reports,omitempty"`
        UniqueClicks     int `json:"unique_clicks,omitempty"`
        UniqueOpens      int `json:"unique_opens,omitempty"`
        UnsubscribeDrops int `json:"unsubscribe_drops,omitempty"`
        Unsubscribes     int `json:"unsubscribes,omitempty"`
}

// GlobalStat represents global statistics
type GlobalStat struct {
        Date  string      `json:"date,omitempty"`
        Stats StatMetrics `json:"stats,omitempty"`
}

// CategoryStat represents category statistics
type CategoryStat struct {
        Date  string     `json:"date,omitempty"`
        Stats []StatItem `json:"stats,omitempty"`
}

// SubuserStat represents subuser statistics
type SubuserStat struct {
        Date  string     `json:"date,omitempty"`
        Stats []StatItem `json:"stats,omitempty"`
}

// StatsOptions represents query parameters for stats requests
type StatsOptions struct {
        StartDate   string   `url:"start_date,omitempty"`
        EndDate     string   `url:"end_date,omitempty"`
        Aggregation string   `url:"aggregated_by,omitempty"`
        Categories  []string `url:"-"`
        Subusers    []string `url:"-"`
        Tags        []string `url:"-"`
        Limit       int      `url:"limit,omitempty"`
        Offset      int      `url:"offset,omitempty"`
}

// GetGlobalStats retrieves global email statistics
// see: https://www.twilio.com/docs/sendgrid/api-reference/stats/retrieve-global-email-statistics
func (c *Client) GetGlobalStats(ctx context.Context, opts *StatsOptions) ([]GlobalStat, error) <span class="cov8" title="1">{
        path := "/stats"

        if opts != nil </span><span class="cov8" title="1">{
                var err error
                path, err = c.AddOptions(path, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var stats []GlobalStat
        if err := c.Do(ctx, req, &amp;stats); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}

// GetCategoryStats retrieves category email statistics
// see: https://www.twilio.com/docs/sendgrid/api-reference/categories-statistics/retrieve-email-statistics-for-categories
func (c *Client) GetCategoryStats(ctx context.Context, categories []string, opts *StatsOptions) ([]CategoryStat, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/categories/stats?categories=%s", strings.Join(categories, ","))

        if opts != nil </span><span class="cov8" title="1">{
                var err error
                tempPath, err := c.AddOptions("", opts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if tempPath != "" </span><span class="cov8" title="1">{
                        if strings.Contains(path, "?") </span><span class="cov8" title="1">{
                                path += "&amp;" + strings.TrimPrefix(tempPath, "?")
                        }</span> else<span class="cov0" title="0"> {
                                path += tempPath
                        }</span>
                }
        }

        <span class="cov8" title="1">req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var stats []CategoryStat
        if err := c.Do(ctx, req, &amp;stats); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}

// GetCategorySums retrieves category sums
// see: https://www.twilio.com/docs/sendgrid/api-reference/categories-statistics/retrieve-sums-of-email-stats-for-each-category
func (c *Client) GetCategorySums(ctx context.Context, opts *StatsOptions) ([]CategoryStat, error) <span class="cov8" title="1">{
        path := "/categories/stats/sums"

        if opts != nil </span><span class="cov8" title="1">{
                var err error
                path, err = c.AddOptions(path, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var stats []CategoryStat
        if err := c.Do(ctx, req, &amp;stats); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}

// GetSubuserStats retrieves subuser email statistics
// see: https://www.twilio.com/docs/sendgrid/api-reference/subuser-statistics/retrieve-email-statistics-for-your-subusers
func (c *Client) GetSubuserStats(ctx context.Context, subusers []string, opts *StatsOptions) ([]SubuserStat, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/subusers/stats?subusers=%s", strings.Join(subusers, ","))

        if opts != nil </span><span class="cov8" title="1">{
                var err error
                tempPath, err := c.AddOptions("", opts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if tempPath != "" </span><span class="cov8" title="1">{
                        if strings.Contains(path, "?") </span><span class="cov8" title="1">{
                                path += "&amp;" + strings.TrimPrefix(tempPath, "?")
                        }</span> else<span class="cov0" title="0"> {
                                path += tempPath
                        }</span>
                }
        }

        <span class="cov8" title="1">req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var stats []SubuserStat
        if err := c.Do(ctx, req, &amp;stats); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}

// GetSubuserSums retrieves subuser sums
// see: https://www.twilio.com/docs/sendgrid/api-reference/subuser-statistics/retrieve-sums-of-email-stats-for-each-subuser
func (c *Client) GetSubuserSums(ctx context.Context, opts *StatsOptions) ([]SubuserStat, error) <span class="cov8" title="1">{
        path := "/subusers/stats/sums"

        if opts != nil </span><span class="cov8" title="1">{
                var err error
                path, err = c.AddOptions(path, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var stats []SubuserStat
        if err := c.Do(ctx, req, &amp;stats); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}

// GetSubuserMonthlyStats retrieves monthly subuser statistics
// see: https://www.twilio.com/docs/sendgrid/api-reference/subuser-statistics/retrieve-monthly-stats-for-all-subusers
func (c *Client) GetSubuserMonthlyStats(ctx context.Context, opts *StatsOptions) ([]SubuserStat, error) <span class="cov8" title="1">{
        path := "/subusers/stats/monthly"

        if opts != nil </span><span class="cov8" title="1">{
                var err error
                path, err = c.AddOptions(path, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var stats []SubuserStat
        if err := c.Do(ctx, req, &amp;stats); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package sendgrid

import (
        "context"
        "fmt"
        "net/url"
        "strconv"
)

type Subuser struct {
        ID       int64  `json:"id,omitempty"`
        Disabled bool   `json:"disabled,omitempty"`
        Username string `json:"username,omitempty"`
        Email    string `json:"email,omitempty"`
}

type InputGetSubusers struct {
        Username string
        Limit    int
        Offset   int
}

func (c *Client) GetSubusers(ctx context.Context, input *InputGetSubusers) ([]*Subuser, error) <span class="cov8" title="1">{
        u, err := url.Parse("/subusers")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">q := u.Query()
        if input.Username != "" </span><span class="cov8" title="1">{
                q.Set("username", input.Username)
        }</span>
        <span class="cov8" title="1">if input.Limit &gt; 0 </span><span class="cov8" title="1">{
                q.Set("limit", strconv.Itoa(input.Limit))
        }</span>
        <span class="cov8" title="1">if input.Offset &gt; 0 </span><span class="cov8" title="1">{
                q.Set("offset", strconv.Itoa(input.Offset))
        }</span>
        <span class="cov8" title="1">u.RawQuery = q.Encode()

        req, err := c.NewRequest("GET", u.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := []*Subuser{}
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type Reputation struct {
        Reputation float64 `json:"reputation,omitempty"`
        Username   string  `json:"username,omitempty"`
}

func (c *Client) GetSubuserReputations(ctx context.Context, usernames string) ([]*Reputation, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/subusers/reputations?usernames=%s", usernames)

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := []*Reputation{}
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

type InputCreateSubuser struct {
        Username string   `json:"username"`
        Email    string   `json:"email"`
        Password string   `json:"password"`
        Ips      []string `json:"ips"`
}

type OutputCreateSubuser struct {
        UserID             int64            `json:"user_id"`
        Username           string           `json:"username"`
        Email              string           `json:"email"`
        SignupSessionToken string           `json:"signup_session_token"`
        AuthorizationToken string           `json:"authorization_token"`
        CreditAllocation   CreditAllocation `json:"credit_allocation"`
}

type CreditAllocation struct {
        Type string `json:"type"`
}

func (c *Client) CreateSubuser(ctx context.Context, input *InputCreateSubuser) (*OutputCreateSubuser, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("POST", "/subusers", input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputCreateSubuser)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateSubuserStatus struct {
        Disabled bool `json:"disabled"`
}

func (c *Client) UpdateSubuserStatus(ctx context.Context, username string, input *InputUpdateSubuserStatus) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/subusers/%s", username)

        req, err := c.NewRequest("PATCH", path, input)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (c *Client) UpdateSubuserIps(ctx context.Context, username string, ips []string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/subusers/%s/ips", username)

        req, err := c.NewRequest("PUT", path, ips)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (c *Client) DeleteSubuser(ctx context.Context, username string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/subusers/%s", username)

        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package sendgrid

import (
        "context"
        "fmt"
        "net/url"
)

// Bounce represents a bounced email
type Bounce struct {
        Created int64  `json:"created"`
        Email   string `json:"email"`
        Reason  string `json:"reason"`
        Status  string `json:"status"`
}

// Block represents a blocked email
type Block struct {
        Created int64  `json:"created"`
        Email   string `json:"email"`
        Reason  string `json:"reason"`
}

// SpamReport represents a spam report
type SpamReport struct {
        Created int64  `json:"created"`
        Email   string `json:"email"`
        IP      string `json:"ip"`
}

// InvalidEmail represents an invalid email
type InvalidEmail struct {
        Created int64  `json:"created"`
        Email   string `json:"email"`
        Reason  string `json:"reason"`
}

// OutputGetBounces represents the response for bounces list
type OutputGetBounces struct {
        Bounces []Bounce `json:"bounces,omitempty"`
}

// OutputGetBlocks represents the response for blocks list
type OutputGetBlocks struct {
        Blocks []Block `json:"blocks,omitempty"`
}

// OutputGetSpamReports represents the response for spam reports list
type OutputGetSpamReports struct {
        SpamReports []SpamReport `json:"spam_reports,omitempty"`
}

// OutputGetInvalidEmails represents the response for invalid emails list
type OutputGetInvalidEmails struct {
        InvalidEmails []InvalidEmail `json:"invalid_emails,omitempty"`
}

// InputDeleteSuppressions represents the request body for deleting suppressions
type InputDeleteSuppressions struct {
        Emails    []string `json:"emails,omitempty"`
        DeleteAll bool     `json:"delete_all,omitempty"`
}

// SuppressionListOptions represents query parameters for suppression list requests
type SuppressionListOptions struct {
        StartTime int64  `url:"start_time,omitempty"`
        EndTime   int64  `url:"end_time,omitempty"`
        Limit     int    `url:"limit,omitempty"`
        Offset    int    `url:"offset,omitempty"`
        Email     string `url:"email,omitempty"`
}

// GetBounces retrieves all bounces
// see: https://www.twilio.com/docs/sendgrid/api-reference/bounces/retrieve-all-bounces
func (c *Client) GetBounces(ctx context.Context, opts *SuppressionListOptions) ([]Bounce, error) <span class="cov8" title="1">{
        path := "/suppression/bounces"

        if opts != nil </span><span class="cov8" title="1">{
                var err error
                path, err = c.AddOptions(path, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var bounces []Bounce
        if err := c.Do(ctx, req, &amp;bounces); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return bounces, nil</span>
}

// GetBounce retrieves a specific bounce
// see: https://www.twilio.com/docs/sendgrid/api-reference/bounces/retrieve-a-bounce
func (c *Client) GetBounce(ctx context.Context, email string) (*Bounce, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/suppression/bounces/%s", url.QueryEscape(email))

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var bounces []Bounce
        if err := c.Do(ctx, req, &amp;bounces); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(bounces) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("bounce not found for email: %s", email)
        }</span>

        <span class="cov8" title="1">return &amp;bounces[0], nil</span>
}

// DeleteBounces deletes bounces
// see: https://www.twilio.com/docs/sendgrid/api-reference/bounces/delete-bounces
func (c *Client) DeleteBounces(ctx context.Context, input *InputDeleteSuppressions) error <span class="cov8" title="1">{
        path := "/suppression/bounces"

        req, err := c.NewRequest("DELETE", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DeleteBounce deletes a specific bounce
// see: https://www.twilio.com/docs/sendgrid/api-reference/bounces/delete-a-bounce
func (c *Client) DeleteBounce(ctx context.Context, email string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/suppression/bounces/%s", url.QueryEscape(email))

        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetBlocks retrieves all blocks
// see: https://www.twilio.com/docs/sendgrid/api-reference/blocks/retrieve-all-blocks
func (c *Client) GetBlocks(ctx context.Context, opts *SuppressionListOptions) ([]Block, error) <span class="cov8" title="1">{
        path := "/suppression/blocks"

        if opts != nil </span><span class="cov8" title="1">{
                var err error
                path, err = c.AddOptions(path, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var blocks []Block
        if err := c.Do(ctx, req, &amp;blocks); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return blocks, nil</span>
}

// GetBlock retrieves a specific block
// see: https://www.twilio.com/docs/sendgrid/api-reference/blocks/retrieve-a-specific-block
func (c *Client) GetBlock(ctx context.Context, email string) (*Block, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/suppression/blocks/%s", url.QueryEscape(email))

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var blocks []Block
        if err := c.Do(ctx, req, &amp;blocks); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(blocks) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("block not found for email: %s", email)
        }</span>

        <span class="cov8" title="1">return &amp;blocks[0], nil</span>
}

// DeleteBlocks deletes blocks
// see: https://www.twilio.com/docs/sendgrid/api-reference/blocks/delete-blocks
func (c *Client) DeleteBlocks(ctx context.Context, input *InputDeleteSuppressions) error <span class="cov8" title="1">{
        path := "/suppression/blocks"

        req, err := c.NewRequest("DELETE", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DeleteBlock deletes a specific block
// see: https://www.twilio.com/docs/sendgrid/api-reference/blocks/delete-a-specific-block
func (c *Client) DeleteBlock(ctx context.Context, email string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/suppression/blocks/%s", url.QueryEscape(email))

        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetSpamReports retrieves all spam reports
// see: https://www.twilio.com/docs/sendgrid/api-reference/spam-reports/retrieve-all-spam-reports
func (c *Client) GetSpamReports(ctx context.Context, opts *SuppressionListOptions) ([]SpamReport, error) <span class="cov8" title="1">{
        path := "/suppression/spam_reports"

        if opts != nil </span><span class="cov8" title="1">{
                var err error
                path, err = c.AddOptions(path, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var spamReports []SpamReport
        if err := c.Do(ctx, req, &amp;spamReports); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return spamReports, nil</span>
}

// GetSpamReport retrieves a specific spam report
// see: https://www.twilio.com/docs/sendgrid/api-reference/spam-reports/retrieve-a-specific-spam-report
func (c *Client) GetSpamReport(ctx context.Context, email string) (*SpamReport, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/suppression/spam_reports/%s", url.QueryEscape(email))

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var spamReports []SpamReport
        if err := c.Do(ctx, req, &amp;spamReports); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(spamReports) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("spam report not found for email: %s", email)
        }</span>

        <span class="cov8" title="1">return &amp;spamReports[0], nil</span>
}

// DeleteSpamReports deletes spam reports
// see: https://www.twilio.com/docs/sendgrid/api-reference/spam-reports/delete-spam-reports
func (c *Client) DeleteSpamReports(ctx context.Context, input *InputDeleteSuppressions) error <span class="cov8" title="1">{
        path := "/suppression/spam_reports"

        req, err := c.NewRequest("DELETE", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DeleteSpamReport deletes a specific spam report
// see: https://www.twilio.com/docs/sendgrid/api-reference/spam-reports/delete-a-specific-spam-report
func (c *Client) DeleteSpamReport(ctx context.Context, email string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/suppression/spam_reports/%s", url.QueryEscape(email))

        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetInvalidEmails retrieves all invalid emails
// see: https://www.twilio.com/docs/sendgrid/api-reference/invalid-emails/retrieve-all-invalid-emails
func (c *Client) GetInvalidEmails(ctx context.Context, opts *SuppressionListOptions) ([]InvalidEmail, error) <span class="cov8" title="1">{
        path := "/suppression/invalid_emails"

        if opts != nil </span><span class="cov8" title="1">{
                var err error
                path, err = c.AddOptions(path, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var invalidEmails []InvalidEmail
        if err := c.Do(ctx, req, &amp;invalidEmails); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return invalidEmails, nil</span>
}

// GetInvalidEmail retrieves a specific invalid email
// see: https://www.twilio.com/docs/sendgrid/api-reference/invalid-emails/retrieve-an-invalid-email
func (c *Client) GetInvalidEmail(ctx context.Context, email string) (*InvalidEmail, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/suppression/invalid_emails/%s", url.QueryEscape(email))

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var invalidEmails []InvalidEmail
        if err := c.Do(ctx, req, &amp;invalidEmails); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(invalidEmails) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid email not found: %s", email)
        }</span>

        <span class="cov8" title="1">return &amp;invalidEmails[0], nil</span>
}

// DeleteInvalidEmails deletes invalid emails
// see: https://www.twilio.com/docs/sendgrid/api-reference/invalid-emails/delete-invalid-emails
func (c *Client) DeleteInvalidEmails(ctx context.Context, input *InputDeleteSuppressions) error <span class="cov8" title="1">{
        path := "/suppression/invalid_emails"

        req, err := c.NewRequest("DELETE", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DeleteInvalidEmail deletes a specific invalid email
// see: https://www.twilio.com/docs/sendgrid/api-reference/invalid-emails/delete-a-specific-invalid-email
func (c *Client) DeleteInvalidEmail(ctx context.Context, email string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/suppression/invalid_emails/%s", url.QueryEscape(email))

        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package sendgrid

import (
        "context"
        "fmt"
        "strconv"
)

type SuppressionGroup struct {
        ID              int64  `json:"id,omitempty"`
        Name            string `json:"name,omitempty"`
        Description     string `json:"description,omitempty"`
        IsDefault       bool   `json:"is_default,omitempty"`
        Unsubscribes    int64  `json:"unsubscribes,omitempty"`
        LastEmailSentAt string `json:"last_email_sent_at,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/suppressions-unsubscribe-groups/get-information-on-a-single-suppression-group
func (c *Client) GetSuppressionGroup(ctx context.Context, id int64) (*SuppressionGroup, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/asm/groups/%s", strconv.FormatInt(id, 10))

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(SuppressionGroup)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

// see: https://docs.sendgrid.com/api-reference/suppressions-unsubscribe-groups/retrieve-all-suppression-groups-associated-with-the-user
func (c *Client) GetSuppressionGroups(ctx context.Context) ([]*SuppressionGroup, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("GET", "/asm/groups", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := []*SuppressionGroup{}
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputCreateSuppressionGroup struct {
        Name        string `json:"name,omitempty"`
        Description string `json:"description,omitempty"`
        IsDefault   bool   `json:"is_default"`
}

type OutputCreateSuppressionGroup struct {
        ID          int64  `json:"id,omitempty"`
        Name        string `json:"name,omitempty"`
        Description string `json:"description,omitempty"`
        IsDefault   bool   `json:"is_default,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/suppressions-unsubscribe-groups/create-a-new-suppression-group
func (c *Client) CreateSuppressionGroup(ctx context.Context, input *InputCreateSuppressionGroup) (*OutputCreateSuppressionGroup, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("POST", "/asm/groups", input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputCreateSuppressionGroup)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateSuppressionGroup struct {
        Name        string `json:"name,omitempty"`
        Description string `json:"description,omitempty"`
        IsDefault   bool   `json:"is_default"`
}

type OutputUpdateSuppressionGroup struct {
        ID              int64  `json:"id,omitempty"`
        Name            string `json:"name,omitempty"`
        Description     string `json:"description,omitempty"`
        IsDefault       bool   `json:"is_default,omitempty"`
        LastEmailSentAt string `json:"last_email_sent_at,omitempty"`
        Unsubscribes    int64  `json:"unsubscribes,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/suppressions-unsubscribe-groups/update-a-suppression-group
func (c *Client) UpdateSuppressionGroup(ctx context.Context, id int64, input *InputUpdateSuppressionGroup) (*OutputUpdateSuppressionGroup, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/asm/groups/%s", strconv.FormatInt(id, 10))

        req, err := c.NewRequest("PATCH", path, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateSuppressionGroup)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

// see: https://docs.sendgrid.com/api-reference/suppressions-unsubscribe-groups/delete-a-suppression-group
func (c *Client) DeleteSuppressionGroup(ctx context.Context, id int64) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/asm/groups/%s", strconv.FormatInt(id, 10))

        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package sendgrid

import (
        "context"
        "fmt"
        "net/url"
        "strconv"
)

// consolidating normal teammate and SSO teammate fields
type Member struct {
        Teammate

        Company string   `json:"company,omitempty"`
        IsSSO   bool     `json:"is_sso,omitempty"`
        Scopes  []string `json:"scopes,omitempty"`
}

type OutputGetTeammate struct {
        Username  string   `json:"username,omitempty"`
        FirstName string   `json:"first_name,omitempty"`
        LastName  string   `json:"last_name,omitempty"`
        Email     string   `json:"email,omitempty"`
        Scopes    []string `json:"scopes,omitempty"`
        UserType  string   `json:"user_type,omitempty"`
        IsAdmin   bool     `json:"is_admin,omitempty"`
        Phone     string   `json:"phone,omitempty"`
        Website   string   `json:"website,omitempty"`
        Address   string   `json:"address,omitempty"`
        Address2  string   `json:"address2,omitempty"`
        City      string   `json:"city,omitempty"`
        State     string   `json:"state,omitempty"`
        Zip       string   `json:"zip,omitempty"`
        Country   string   `json:"country,omitempty"`
}

func (c *Client) GetTeammate(ctx context.Context, username string) (*OutputGetTeammate, error) <span class="cov8" title="1">{
        u := fmt.Sprintf("/teammates/%s", username)

        req, err := c.NewRequest("GET", u, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetTeammate)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type Teammate struct {
        Username  string `json:"username,omitempty"`
        Email     string `json:"email,omitempty"`
        FirstName string `json:"first_name,omitempty"`
        LastName  string `json:"last_name,omitempty"`
        UserType  string `json:"user_type,omitempty"`
        IsAdmin   bool   `json:"is_admin,omitempty"`
        Phone     string `json:"phone,omitempty"`
        Website   string `json:"website,omitempty"`
        Address   string `json:"address,omitempty"`
        Address2  string `json:"address2,omitempty"`
        City      string `json:"city,omitempty"`
        State     string `json:"state,omitempty"`
        Zip       string `json:"zip,omitempty"`
        Country   string `json:"country,omitempty"`
}

type InputGetTeammates struct {
        Limit  int `json:"limit,omitempty"`
        Offset int `json:"offset,omitempty"`
}

type OutputGetTeammates struct {
        Teammates []Teammate `json:"result,omitempty"`
}

func (c *Client) GetTeammates(ctx context.Context, input *InputGetTeammates) (*OutputGetTeammates, error) <span class="cov8" title="1">{
        u, err := url.Parse("/teammates")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if input != nil </span><span class="cov8" title="1">{
                q := u.Query()
                if input.Limit &gt; 0 </span><span class="cov8" title="1">{
                        q.Set("limit", strconv.Itoa(input.Limit))
                }</span>
                <span class="cov8" title="1">if input.Offset &gt; 0 </span><span class="cov8" title="1">{
                        q.Set("offset", strconv.Itoa(input.Offset))
                }</span>
                <span class="cov8" title="1">u.RawQuery = q.Encode()</span>
        }

        <span class="cov8" title="1">req, err := c.NewRequest("GET", u.String(), nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetTeammates)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type PendingTeammate struct {
        Email          string   `json:"email,omitempty"`
        Scopes         []string `json:"scopes,omitempty"`
        IsAdmin        bool     `json:"is_admin,omitempty"`
        Token          string   `json:"token,omitempty"`
        ExpirationDate int      `json:"expiration_date,omitempty"`
}

type OutputGetPendingTeammates struct {
        PendingTeammates []PendingTeammate `json:"result,omitempty"`
}

func (c *Client) GetPendingTeammates(ctx context.Context) (*OutputGetPendingTeammates, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("GET", "/teammates/pending", nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetPendingTeammates)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputInviteTeammate struct {
        Email   string   `json:"email"`
        IsAdmin bool     `json:"is_admin"`
        Scopes  []string `json:"scopes"`
}

type OutputInviteTeammate struct {
        Token   string   `json:"token,omitempty"`
        Email   string   `json:"email"`
        IsAdmin bool     `json:"is_admin"`
        Scopes  []string `json:"scopes"`
}

func (c *Client) InviteTeammate(ctx context.Context, input *InputInviteTeammate) (*OutputInviteTeammate, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("POST", "/teammates", input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputInviteTeammate)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateTeammatePermissions struct {
        IsAdmin bool     `json:"is_admin"`
        Scopes  []string `json:"scopes"`
}

type OutputUpdateTeammatePermissions struct {
        Username  string   `json:"username,omitempty"`
        FirstName string   `json:"first_name,omitempty"`
        LastName  string   `json:"last_name,omitempty"`
        Email     string   `json:"email,omitempty"`
        Scopes    []string `json:"scopes,omitempty"`
        UserType  string   `json:"user_type,omitempty"`
        IsAdmin   bool     `json:"is_admin,omitempty"`
        Phone     string   `json:"phone,omitempty"`
        Website   string   `json:"website,omitempty"`
        Address   string   `json:"address,omitempty"`
        Address2  string   `json:"address2,omitempty"`
        City      string   `json:"city,omitempty"`
        State     string   `json:"state,omitempty"`
        Zip       string   `json:"zip,omitempty"`
        Country   string   `json:"country,omitempty"`
}

func (c *Client) UpdateTeammatePermissions(ctx context.Context, username string, input *InputUpdateTeammatePermissions) (*OutputUpdateTeammatePermissions, error) <span class="cov8" title="1">{
        u := fmt.Sprintf("/teammates/%s", username)

        req, err := c.NewRequest("PATCH", u, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateTeammatePermissions)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

func (c *Client) DeleteTeammate(ctx context.Context, username string) error <span class="cov8" title="1">{
        u := fmt.Sprintf("/teammates/%s", username)

        req, err := c.NewRequest("DELETE", u, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (c *Client) DeletePendingTeammate(ctx context.Context, token string) error <span class="cov8" title="1">{
        u := fmt.Sprintf("/teammates/pending/%s", token)

        req, err := c.NewRequest("DELETE", u, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type InputGetTeammateSubuserAccess struct {
        AfterSubuserID int64  `json:"after_subuser_id,omitempty"`
        Limit          int64  `json:"limit,omitempty"`
        Username       string `json:"username,omitempty"`
}
type OutputGetTeammateSubuserAccess struct {
        HasRestrictedSubuserAccess bool                             `json:"has_restricted_subuser_access,omitempty"`
        SubuserAccess              []SubuserAccess                  `json:"subuser_access,omitempty"`
        Metadata                   MetadataGetTeammateSubuserAccess `json:"_metadata,omitempty"`
}

type SubuserAccess struct {
        ID             int64    `json:"id,omitempty"`
        Username       string   `json:"username,omitempty"`
        Email          string   `json:"email,omitempty"`
        Disabled       bool     `json:"disabled,omitempty"`
        PermissionType string   `json:"permission_type,omitempty"`
        Scopes         []string `json:"scopes,omitempty"`
}

type MetadataGetTeammateSubuserAccess struct {
        NextParams NextParams `json:"next_params,omitempty"`
}

type NextParams struct {
        Limit          int64  `json:"limit"`
        AfterSubuserID int64  `json:"after_subuser_id,omitempty"`
        Username       string `json:"username,omitempty"`
}

// see: https://www.twilio.com/docs/sendgrid/api-reference/teammates/get-teammate-subuser-access
func (c *Client) GetTeammateSubuserAccess(ctx context.Context, teammateName string, input *InputGetTeammateSubuserAccess) (*OutputGetTeammateSubuserAccess, error) <span class="cov8" title="1">{
        p := fmt.Sprintf("/teammates/%s/subuser_access", teammateName)
        u, err := url.Parse(p)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">q := u.Query()
        if input.AfterSubuserID &gt; 0 </span><span class="cov8" title="1">{
                q.Set("after_subuser_id", strconv.FormatInt(input.AfterSubuserID, 10))
        }</span>
        <span class="cov8" title="1">if input.Limit &gt; 0 </span><span class="cov8" title="1">{
                q.Set("limit", strconv.FormatInt(input.Limit, 10))
        }</span>
        <span class="cov8" title="1">if input.Username != "" </span><span class="cov8" title="1">{
                q.Set("username", input.Username)
        }</span>

        <span class="cov8" title="1">req, err := c.NewRequest("GET", u.String(), nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetTeammateSubuserAccess)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputCreateSSOTeammate struct {
        Email                      string               `json:"email"`
        FirstName                  string               `json:"first_name"`
        LastName                   string               `json:"last_name"`
        IsAdmin                    bool                 `json:"is_admin"`
        IsSSO                      bool                 `json:"is_sso"`
        Persona                    string               `json:"persona,omitempty"`
        Scopes                     []string             `json:"scopes,omitempty"`
        HasRestrictedSubuserAccess bool                 `json:"has_restricted_subuser_access,omitempty"`
        SubuserAccess              []InputSubuserAccess `json:"subuser_access,omitempty"`
}

type InputSubuserAccess struct {
        ID             int64    `json:"id,omitempty"`
        PermissionType string   `json:"permission_type,omitempty"`
        Scopes         []string `json:"scopes,omitempty"`
}

type OutputCreateSSOTeammate struct {
        FirstName                  string                `json:"first_name,omitempty"`
        LastName                   string                `json:"last_name,omitempty"`
        Email                      string                `json:"email,omitempty"`
        IsAdmin                    bool                  `json:"is_admin,omitempty"`
        IsSSO                      bool                  `json:"is_sso,omitempty"`
        Scopes                     []string              `json:"scopes,omitempty"`
        HasRestrictedSubuserAccess bool                  `json:"has_restricted_subuser_access,omitempty"`
        SubuserAccess              []OutputSubuserAccess `json:"subuser_access,omitempty"`
}

type OutputSubuserAccess struct {
        ID             int64    `json:"id,omitempty"`
        Username       string   `json:"username,omitempty"`
        Email          string   `json:"email,omitempty"`
        Disabled       bool     `json:"disabled,omitempty"`
        PermissionType string   `json:"permission_type,omitempty"`
        Scopes         []string `json:"scopes,omitempty"`
}

// see: https://www.twilio.com/docs/sendgrid/api-reference/single-sign-on-teammates/create-sso-teammate
func (c *Client) CreateSSOTeammate(ctx context.Context, input *InputCreateSSOTeammate) (*OutputCreateSSOTeammate, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("POST", "/sso/teammates", input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputCreateSSOTeammate)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateSSOTeammate struct {
        FirstName                  string               `json:"first_name"`
        LastName                   string               `json:"last_name"`
        IsAdmin                    bool                 `json:"is_admin"`
        Persona                    string               `json:"persona,omitempty"`
        Scopes                     []string             `json:"scopes,omitempty"`
        HasRestrictedSubuserAccess bool                 `json:"has_restricted_subuser_access,omitempty"`
        SubuserAccess              []InputSubuserAccess `json:"subuser_access,omitempty"`
}

type OutputUpdateSSOTeammate struct {
        Address                    string                `json:"address,omitempty"`
        Address2                   string                `json:"address2,omitempty"`
        City                       string                `json:"city,omitempty"`
        Company                    string                `json:"company,omitempty"`
        Country                    string                `json:"country,omitempty"`
        Username                   string                `json:"username,omitempty"`
        Phone                      string                `json:"phone,omitempty"`
        State                      string                `json:"state,omitempty"`
        UserType                   string                `json:"user_type,omitempty"`
        Website                    string                `json:"website,omitempty"`
        Zip                        string                `json:"zip,omitempty"`
        FirstName                  string                `json:"first_name,omitempty"`
        LastName                   string                `json:"last_name,omitempty"`
        Email                      string                `json:"email,omitempty"`
        IsAdmin                    bool                  `json:"is_admin,omitempty"`
        IsSSO                      bool                  `json:"is_sso,omitempty"`
        Scopes                     []string              `json:"scopes,omitempty"`
        HasRestrictedSubuserAccess bool                  `json:"has_restricted_subuser_access,omitempty"`
        SubuserAccess              []OutputSubuserAccess `json:"subuser_access,omitempty"`
}

// see: https://www.twilio.com/docs/sendgrid/api-reference/single-sign-on-teammates/edit-an-sso-teammate
func (c *Client) UpdateSSOTeammate(ctx context.Context, username string, input *InputUpdateSSOTeammate) (*OutputUpdateSSOTeammate, error) <span class="cov8" title="1">{
        u := fmt.Sprintf("/sso/teammates/%s", username)
        req, err := c.NewRequest("PATCH", u, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateSSOTeammate)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package sendgrid

import (
        "context"
        "fmt"
        "net/url"
        "strconv"
)

type OutputGetTemplate struct {
        ID         string    `json:"id,omitempty"`
        Name       string    `json:"name,omitempty"`
        Generation string    `json:"generation,omitempty"`
        UpdatedAt  string    `json:"updated_at,omitempty"`
        Versions   []Version `json:"versions,omitempty"`
        Warning    Warning   `json:"warning,omitempty"`
}

type Version struct {
        ID                   string `json:"id,omitempty"`
        TemplateID           string `json:"template_id,omitempty"`
        Name                 string `json:"name,omitempty"`
        Subject              string `json:"subject,omitempty"`
        UpdatedAt            string `json:"updated_at,omitempty"`
        GeneratePlainContent bool   `json:"generate_plain_content,omitempty"`
        HTMLContent          string `json:"html_content,omitempty"`
        PlainContent         string `json:"plain_content,omitempty"`
        Editor               string `json:"editor,omitempty"`
        ThumbnailURL         string `json:"thumbnail_url,omitempty"`
}

type Warning struct {
        Message string `json:"message,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/transactional-templates/retrieve-a-single-transactional-template
func (c *Client) GetTemplate(ctx context.Context, id string) (*OutputGetTemplate, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/templates/%s", id)

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetTemplate)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputGetTemplates struct {
        Generations string
        PageSize    int
        PageToken   string
}

type OutputGetTemplates struct {
        Templates []Template `json:"result,omitempty"`
        Metadata  Metadata   `json:"_metadata,omitempty"`
}

type Template struct {
        ID         string    `json:"id,omitempty"`
        Name       string    `json:"name,omitempty"`
        Generation string    `json:"generation,omitempty"`
        UpdatedAt  string    `json:"updated_at,omitempty"`
        Versions   []Version `json:"versions,omitempty"`
}

type Metadata struct {
        Prev  string `json:"prev,omitempty"`
        Self  string `json:"self,omitempty"`
        Next  string `json:"next,omitempty"`
        Count int    `json:"count,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/transactional-templates/retrieve-paged-transactional-templates
func (c *Client) GetTemplates(ctx context.Context, input *InputGetTemplates) (*OutputGetTemplates, error) <span class="cov8" title="1">{
        u, err := url.Parse("/templates")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">q := u.Query()
        if input.Generations != "" </span><span class="cov8" title="1">{
                q.Set("generations", input.Generations)
        }</span>
        <span class="cov8" title="1">if input.PageSize &gt; 0 </span><span class="cov8" title="1">{
                q.Set("page_size", strconv.Itoa(input.PageSize))
        }</span>
        <span class="cov8" title="1">if input.PageToken != "" </span><span class="cov8" title="1">{
                q.Set("page_token", input.PageToken)
        }</span>
        <span class="cov8" title="1">u.RawQuery = q.Encode()

        req, err := c.NewRequest("GET", u.String(), nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetTemplates)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputCreateTemplate struct {
        Name       string `json:"name,omitempty"`
        Generation string `json:"generation,omitempty"`
}

type OutputCreateTemplate struct {
        ID         string    `json:"id,omitempty"`
        Name       string    `json:"name,omitempty"`
        Generation string    `json:"generation,omitempty"`
        UpdatedAt  string    `json:"updated_at,omitempty"`
        Versions   []Version `json:"versions,omitempty"`
        Warning    Warning   `json:"warning,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/transactional-templates/create-a-transactional-template
func (c *Client) CreateTemplate(ctx context.Context, input *InputCreateTemplate) (*OutputCreateTemplate, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("POST", "/templates", input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputCreateTemplate)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

type InputDuplicateTemplate struct {
        Name string `json:"name,omitempty"`
}

type OutputDuplicateTemplate struct {
        ID         string    `json:"id,omitempty"`
        Name       string    `json:"name,omitempty"`
        Generation string    `json:"generation,omitempty"`
        UpdatedAt  string    `json:"updated_at,omitempty"`
        Versions   []Version `json:"versions,omitempty"`
        Warning    Warning   `json:"warning,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/transactional-templates/duplicate-a-transactional-template
func (c *Client) DuplicateTemplate(ctx context.Context, id string, input *InputDuplicateTemplate) (*OutputDuplicateTemplate, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/templates/%s", id)
        req, err := c.NewRequest("POST", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputDuplicateTemplate)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateTemplate struct {
        Name string `json:"name,omitempty"`
}

type OutputUpdateTemplate struct {
        ID         string    `json:"id,omitempty"`
        Name       string    `json:"name,omitempty"`
        Generation string    `json:"generation,omitempty"`
        UpdatedAt  string    `json:"updated_at,omitempty"`
        Versions   []Version `json:"versions,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/transactional-templates/edit-a-transactional-template
func (c *Client) UpdateTemplate(ctx context.Context, id string, input *InputUpdateTemplate) (*OutputUpdateTemplate, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/templates/%s", id)

        req, err := c.NewRequest("PATCH", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateTemplate)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

// see: https://docs.sendgrid.com/api-reference/transactional-templates/delete-a-template
func (c *Client) DeleteTemplate(ctx context.Context, id string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/templates/%s", id)

        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package sendgrid

import (
        "context"
        "fmt"
)

type OutputGetTemplateVersion struct {
        ID                   string  `json:"id,omitempty"`
        TemplateID           string  `json:"template_id,omitempty"`
        Active               int     `json:"active,omitempty"`
        Name                 string  `json:"name,omitempty"`
        HTMLContent          string  `json:"html_content,omitempty"`
        PlainContent         string  `json:"plain_content,omitempty"`
        GeneratePlainContent bool    `json:"generate_plain_content,omitempty"`
        Subject              string  `json:"subject,omitempty"`
        Editor               string  `json:"editor,omitempty"`
        TestData             string  `json:"test_data,omitempty"`
        UpdatedAt            string  `json:"updated_at,omitempty"`
        Warnings             Warning `json:"warnings,omitempty"`
        ThumbnailURL         string  `json:"thumbnail_url,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/transactional-templates-versions/retrieve-a-specific-transactional-template-version
func (c *Client) GetTemplateVersion(ctx context.Context, templateID, versionID string) (*OutputGetTemplateVersion, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/templates/%s/versions/%s", templateID, versionID)

        req, err := c.NewRequest("GET", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetTemplateVersion)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputCreateTemplateVersion struct {
        Active               int    `json:"active,omitempty"`
        Name                 string `json:"name,omitempty"`
        HTMLContent          string `json:"html_content,omitempty"`
        PlainContent         string `json:"plain_content,omitempty"`
        GeneratePlainContent bool   `json:"generate_plain_content"`
        Subject              string `json:"subject,omitempty"`
        Editor               string `json:"editor,omitempty"`
        TestData             string `json:"test_data,omitempty"`
}

type OutputCreateTemplateVersion struct {
        ID                   string    `json:"id,omitempty"`
        TemplateID           string    `json:"template_id,omitempty"`
        Active               int       `json:"active,omitempty"`
        Name                 string    `json:"name,omitempty"`
        HTMLContent          string    `json:"html_content,omitempty"`
        PlainContent         string    `json:"plain_content,omitempty"`
        GeneratePlainContent bool      `json:"generate_plain_content,omitempty"`
        Subject              string    `json:"subject,omitempty"`
        Editor               string    `json:"editor,omitempty"`
        TestData             string    `json:"test_data,omitempty"`
        UpdatedAt            string    `json:"updated_at,omitempty"`
        Warnings             []Warning `json:"warnings,omitempty"`
        ThumbnailURL         string    `json:"thumbnail_url,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/transactional-templates-versions/create-a-new-transactional-template-version
func (c *Client) CreateTemplateVersion(ctx context.Context, templateID string, input *InputCreateTemplateVersion) (*OutputCreateTemplateVersion, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/templates/%s/versions", templateID)
        req, err := c.NewRequest("POST", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputCreateTemplateVersion)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateTemplateVersion struct {
        Active               int    `json:"active,omitempty"`
        Name                 string `json:"name,omitempty"`
        HTMLContent          string `json:"html_content,omitempty"`
        PlainContent         string `json:"plain_content,omitempty"`
        GeneratePlainContent bool   `json:"generate_plain_content"`
        Subject              string `json:"subject,omitempty"`
        Editor               string `json:"editor,omitempty"`
        TestData             string `json:"test_data,omitempty"`
}

type OutputUpdateTemplateVersion struct {
        ID                   string    `json:"id,omitempty"`
        TemplateID           string    `json:"template_id,omitempty"`
        Active               int       `json:"active,omitempty"`
        Name                 string    `json:"name,omitempty"`
        HTMLContent          string    `json:"html_content,omitempty"`
        PlainContent         string    `json:"plain_content,omitempty"`
        GeneratePlainContent bool      `json:"generate_plain_content,omitempty"`
        Subject              string    `json:"subject,omitempty"`
        Editor               string    `json:"editor,omitempty"`
        TestData             string    `json:"test_data,omitempty"`
        UpdatedAt            string    `json:"updated_at,omitempty"`
        Warnings             []Warning `json:"warnings,omitempty"`
        ThumbnailURL         string    `json:"thumbnail_url,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/transactional-templates-versions/edit-a-transactional-template-version
func (c *Client) UpdateTemplateVersion(ctx context.Context, templateID, versionID string, input *InputUpdateTemplateVersion) (*OutputUpdateTemplateVersion, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/templates/%s/versions/%s", templateID, versionID)

        req, err := c.NewRequest("PATCH", path, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateTemplateVersion)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type OutputActivateTemplateVersion struct {
        ID                   string    `json:"id,omitempty"`
        TemplateID           string    `json:"template_id,omitempty"`
        Active               int       `json:"active,omitempty"`
        Name                 string    `json:"name,omitempty"`
        HTMLContent          string    `json:"html_content,omitempty"`
        PlainContent         string    `json:"plain_content,omitempty"`
        GeneratePlainContent bool      `json:"generate_plain_content,omitempty"`
        Subject              string    `json:"subject,omitempty"`
        Editor               string    `json:"editor,omitempty"`
        TestData             string    `json:"test_data,omitempty"`
        UpdatedAt            string    `json:"updated_at,omitempty"`
        Warnings             []Warning `json:"warnings,omitempty"`
        ThumbnailURL         string    `json:"thumbnail_url,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/transactional-templates-versions/activate-a-transactional-template-version
func (c *Client) ActivateTemplateVersion(ctx context.Context, templateID, versionID string) (*OutputActivateTemplateVersion, error) <span class="cov8" title="1">{
        path := fmt.Sprintf("/templates/%s/versions/%s/activate", templateID, versionID)

        req, err := c.NewRequest("POST", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputActivateTemplateVersion)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

// see: https://docs.sendgrid.com/api-reference/transactional-templates-versions/delete-a-transactional-template-version
func (c *Client) DeleteTemplateVersion(ctx context.Context, templateID, versionID string) error <span class="cov8" title="1">{
        path := fmt.Sprintf("/templates/%s/versions/%s", templateID, versionID)

        req, err := c.NewRequest("DELETE", path, nil)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := c.Do(ctx, req, nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package sendgrid

import (
        "context"
)

type OutputGetTrackingSettings struct {
        Result []*ResultGetTrackingSettings `json:"result,omitempty"`
}

type ResultGetTrackingSettings struct {
        Name        string `json:"name,omitempty"`
        Title       string `json:"title,omitempty"`
        Description string `json:"description,omitempty"`
        Enabled     bool   `json:"enabled,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/settings-tracking/retrieve-tracking-settings
func (c *Client) GetTrackingSettings(ctx context.Context) (*OutputGetTrackingSettings, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("GET", "/tracking_settings", nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetTrackingSettings)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type OutputGetClickTrackingSettings struct {
        EnableText bool `json:"enable_text,omitempty"`
        Enabled    bool `json:"enabled,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/settings-tracking/retrieve-click-track-settings
func (c *Client) GetClickTrackingSettings(ctx context.Context) (*OutputGetClickTrackingSettings, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("GET", "/tracking_settings/click", nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetClickTrackingSettings)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateClickTrackingSettings struct {
        Enabled bool `json:"enabled"`
}

type OutputUpdateClickTrackingSettings struct {
        EnableText bool `json:"enable_text,omitempty"`
        Enabled    bool `json:"enabled,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/settings-tracking/update-click-tracking-settings
func (c *Client) UpdateClickTrackingSettings(ctx context.Context, input *InputUpdateClickTrackingSettings) (*OutputUpdateClickTrackingSettings, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("PATCH", "/tracking_settings/click", input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateClickTrackingSettings)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type OutputGetOpenTrackingSettings struct {
        Enabled bool `json:"enabled,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/settings-tracking/get-open-tracking-settings
func (c *Client) GetOpenTrackingSettings(ctx context.Context) (*OutputGetOpenTrackingSettings, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("GET", "/tracking_settings/open", nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetOpenTrackingSettings)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateOpenTrackingSettings struct {
        Enabled bool `json:"enabled"`
}

type OutputUpdateOpenTrackingSettings struct {
        Enabled bool `json:"enabled,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/settings-tracking/update-open-tracking-settings
func (c *Client) UpdateOpenTrackingSettings(ctx context.Context, input *InputUpdateOpenTrackingSettings) (*OutputUpdateOpenTrackingSettings, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("PATCH", "/tracking_settings/open", input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateOpenTrackingSettings)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type OutputGetGoogleAnalyticsSettings struct {
        Enabled     bool   `json:"enabled,omitempty"`
        UTMCampaign string `json:"utm_campaign,omitempty"`
        UTMContent  string `json:"utm_content,omitempty"`
        UTMMedium   string `json:"utm_medium,omitempty"`
        UTMSource   string `json:"utm_source,omitempty"`
        UTMTerm     string `json:"utm_term,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/settings-tracking/retrieve-google-analytics-settings
func (c *Client) GetGoogleAnalyticsSettings(ctx context.Context) (*OutputGetGoogleAnalyticsSettings, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("GET", "/tracking_settings/google_analytics", nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetGoogleAnalyticsSettings)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateGoogleAnalyticsSettings struct {
        Enabled     bool   `json:"enabled"`
        UTMCampaign string `json:"utm_campaign,omitempty"`
        UTMContent  string `json:"utm_content,omitempty"`
        UTMMedium   string `json:"utm_medium,omitempty"`
        UTMSource   string `json:"utm_source,omitempty"`
        UTMTerm     string `json:"utm_term,omitempty"`
}

type OutputUpdateGoogleAnalyticsSettings struct {
        Enabled     bool   `json:"enabled,omitempty"`
        UTMCampaign string `json:"utm_campaign,omitempty"`
        UTMContent  string `json:"utm_content,omitempty"`
        UTMMedium   string `json:"utm_medium,omitempty"`
        UTMSource   string `json:"utm_source,omitempty"`
        UTMTerm     string `json:"utm_term,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/settings-tracking/update-google-analytics-settings
func (c *Client) UpdateGoogleAnalyticsSettings(ctx context.Context, input *InputUpdateGoogleAnalyticsSettings) (*OutputUpdateGoogleAnalyticsSettings, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("PATCH", "/tracking_settings/google_analytics", input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateGoogleAnalyticsSettings)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type OutputGetSubscriptionTrackingSettings struct {
        Enabled      bool   `json:"enabled,omitempty"`
        HTMLContent  string `json:"html_content,omitempty"`
        Landing      string `json:"landing,omitempty"`
        PlainContent string `json:"plain_content,omitempty"`
        Replace      string `json:"replace,omitempty"`
        URL          string `json:"url,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/settings-tracking/retrieve-subscription-tracking-settings
func (c *Client) GetSubscriptionTrackingSettings(ctx context.Context) (*OutputGetSubscriptionTrackingSettings, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("GET", "/tracking_settings/subscription", nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputGetSubscriptionTrackingSettings)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

type InputUpdateSubscriptionTrackingSettings struct {
        Enabled      bool   `json:"enabled"`
        HTMLContent  string `json:"html_content,omitempty"`
        Landing      string `json:"landing,omitempty"`
        PlainContent string `json:"plain_content,omitempty"`
        Replace      string `json:"replace,omitempty"`
        URL          string `json:"url,omitempty"`
}

type OutputUpdateSubscriptionTrackingSettings struct {
        Enabled      bool   `json:"enabled,omitempty"`
        HTMLContent  string `json:"html_content,omitempty"`
        Landing      string `json:"landing,omitempty"`
        PlainContent string `json:"plain_content,omitempty"`
        Replace      string `json:"replace,omitempty"`
        URL          string `json:"url,omitempty"`
}

// see: https://docs.sendgrid.com/api-reference/settings-tracking/update-subscription-tracking-settings
func (c *Client) UpdateSubscriptionTrackingSettings(ctx context.Context, input *InputUpdateSubscriptionTrackingSettings) (*OutputUpdateSubscriptionTrackingSettings, error) <span class="cov8" title="1">{
        req, err := c.NewRequest("PATCH", "/tracking_settings/subscription", input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := new(OutputUpdateSubscriptionTrackingSettings)
        if err := c.Do(ctx, req, &amp;r); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
